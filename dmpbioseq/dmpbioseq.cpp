// dmpbioseq.cpp : Defines the entry point for the console application.
//
#include "stdafx.h"

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#if _WIN32
#include "../libbiokanga/commhdrs.h"
#else
#include "../libbiokanga/commhdrs.h"
#endif

const char *cpszProgVer = "1.1.3";		// increment with each releasee

// output format modes
typedef enum TAG_eFMode {
	eFMdefault,					// default is for multifasta
	eFMcsv,						// CSV entries
	eFMbed,						// BED entries
	eFMxml,						// XML entries
	eFMplaceholder				// used to set the enumeration range
	} etFMode;

CStopWatch gStopWatch;
CDiagnostics gDiagnostics;				// for writing diagnostics messages to log file
char gszProcName[_MAX_FNAME];			// process name


etFMode m_FMode;				// output format mode requested by user

int 
Process(char *pszBioSeqFile,char *pszDumpFile, etFMode FMode);

bool WriteDumpFile(int EntryID,char *pszSource,char *pszDescr,int DataLen,UINT8 *pSeq);
bool OpenDumpFile(char *pszDumpFile);
bool CloseDumpFile(void);

#ifdef _WIN32
int _tmain(int argc, char* argv[])
{
// determine my process name
_splitpath(argv[0],NULL,NULL,gszProcName,NULL);
#else
int 
main(int argc, const char** argv)
{
// determine my process name
CUtility::splitpath((char *)argv[0],NULL,gszProcName);
#endif
int iScreenLogLevel;		// level of screen diagnostics
int iFileLogLevel;			// level of file diagnostics
char szLogFile[_MAX_PATH];	// write diagnostics to this file

int Rslt;
etFMode FMode;				// format output mode

char szOutputFileSpec[_MAX_PATH];
char szInputFileSpec[_MAX_PATH];

// command line args
struct arg_lit  *help    = arg_lit0("h","help",                 "print this help and exit");
struct arg_lit  *version = arg_lit0("v","version,ver",			"print version information and exit");
struct arg_int *FileLogLevel=arg_int0("f", "FileLogLevel",		"<int>","Level of diagnostics written to screen and logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
struct arg_file *LogFile = arg_file0("F","log","<file>",		"diagnostics log file");

struct arg_int *format = arg_int0("M","format","<int>",		    "output format: 0 - multifasta, 1 - CSV format only, 2 - BED format, 3 - XML entries only (default: 0)");

struct arg_file *InFile = arg_file1("i","input","<file>",		"input from bioseq files");
struct arg_file *OutFile = arg_file1("o","result","<file>",		"output entry dump file");
struct arg_end *end = arg_end(20);

void *argtable[] = {help,version,FileLogLevel,LogFile,LogFile,format,InFile,OutFile,end};

char **pAllArgs;
int argerrors;
argerrors = CUtility::arg_parsefromfile(argc,(char **)argv,&pAllArgs);
if(argerrors >= 0)
	argerrors = arg_parse(argerrors,pAllArgs,argtable);

/* special case: '--help' takes precedence over error reporting */
if (help->count > 0)
        {
		printf("\n%s Dump biosequence (generated by genbioseq) file contents, Version %s\nOptions ---\n", gszProcName,cpszProgVer);
        arg_print_syntax(stdout,argtable,"\n");
        arg_print_glossary(stdout,argtable,"  %-25s %s\n");
		printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
		printf("\n      To invoke this parameter file then precede it's name with '@'");
		printf("\n      e.g. %s @myparams.txt\n",gszProcName);
		printf("\nPlease report any issues regarding usage of %s to stuart.stephen@csiro.au\n\n",gszProcName);
		exit(1);
        }

    /* special case: '--version' takes precedence error reporting */
if (version->count > 0)
        {
		printf("\n%s Version %s\n",gszProcName,cpszProgVer);
		exit(1);
        }


if (!argerrors)
	{
	if(FileLogLevel->count && !LogFile->count)
		{
		printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>'",FileLogLevel->ival[0]);
		exit(1);
		}

	iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
	if(iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
		printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d",iFileLogLevel,eDLNone,eDLDebug);
		exit(1);
		}
	
	if(LogFile->count)
		{
		strncpy(szLogFile,LogFile->filename[0],_MAX_PATH);
		szLogFile[_MAX_PATH-1] = '\0';
		}
	else
		{
		iFileLogLevel = eDLNone;
		szLogFile[0] = '\0';
		}




	FMode = (etFMode)(format->count ? format->ival[0] : eFMdefault);
	if(FMode < eFMdefault || FMode >= eFMplaceholder)
		{
		printf("\nError: Requested output format '-M%d' not supported, must be in range %d..%d",FMode,eFMdefault,eFMplaceholder-1);
		exit(1);
		}

	strcpy(szInputFileSpec,InFile->filename[0]);
	strcpy(szOutputFileSpec,OutFile->filename[0]);

			// now that command parameters have been parsed then initialise diagnostics log system
	if(!gDiagnostics.Open(szLogFile,(etDiagLevel)iScreenLogLevel,(etDiagLevel)iFileLogLevel,true))
		{
		printf("\nError: Unable to start diagnostics subsystem.");
		if(szLogFile[0] != '\0')
			printf(" Most likely cause is that logfile '%s' can't be opened/created",szLogFile);
		exit(1);
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Version: %s Processing parameters:",cpszProgVer);
	const char *pszDescr;
	switch(FMode) {
		case eFMdefault:			// default is for multifasta
			pszDescr = "Multifasta";
			break;
		case eFMcsv:				// CSV entries
			pszDescr = "CSV format";
			break;
		case eFMbed:				// BED entries
			pszDescr = "BED format";
			break;
		case eFMxml:				// XML entries
			pszDescr = "XML format";
			break;
		}
	
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"dump output format: %s",pszDescr);
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"input biosequence file: '%s'",szInputFileSpec);
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"output to file: '%s'",szOutputFileSpec);	
	
	gStopWatch.Start();
	Rslt = Process(szInputFileSpec,szOutputFileSpec,FMode);
	gStopWatch.Stop();
	Rslt = Rslt >=0 ? 0 : 1;
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Exit code: %d Total processing time: %s",Rslt,gStopWatch.Read());
	exit(Rslt);
	}
else
	{
	printf("\n%s Dump biosequence (generated by genbioseq) file contents, Version %s\n",gszProcName,cpszProgVer);
	arg_print_errors(stdout,end,gszProcName);
	arg_print_syntax(stdout,argtable,"\nUse '-h' to view option and parameter usage\n");
	exit(1);
	}
}

static int hDumpFile =  -1;
static UINT8 *m_pSeq;
static UINT32 m_AllocSeqLen;


int 
Process(char *pszBioSeqFile,
			  char *pszDumpFile,
			  etFMode FMode)
{
CBioSeqFile *pBioSeqFile = NULL;
CMAlignFile *pAlignFile = NULL;
char *pszSpeciesName;
UINT8 *pSeq;

int Len;
char szBuff[cMaxReadLen+ 1];

int Rslt;

char szSource[cBSFSourceSize];
char szDescription[cBSFDescriptionSize];
int SeqLen;
tBSFEntryID CurEntryID;

m_pSeq = NULL;
m_AllocSeqLen = 0;

pBioSeqFile = new CBioSeqFile;
// try to open as a bioseq file
if((Rslt=pBioSeqFile->Open(pszBioSeqFile,cBSFTypeAny,false))!=eBSFSuccess)
	{
	while(pBioSeqFile->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,pBioSeqFile->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open %s",pszBioSeqFile);
	delete pBioSeqFile;
	return(Rslt);
	}
m_FMode = FMode;
if(!OpenDumpFile(pszDumpFile))
	return(eBSFerrOpnFile);

if(m_FMode == eFMbed)
	{
	Len = sprintf(szBuff,"track type=bed name=\"Contigs\" description=\"Contigs dump\"\n");
	CUtility::SafeWrite(hDumpFile,szBuff,Len);
	}


CurEntryID = 0;
pSeq = NULL;
if(pBioSeqFile->GetType() == cBSFTypeMultiAlign)
	{
	pBioSeqFile->Close();
	delete pBioSeqFile;
	pBioSeqFile = NULL;
	pAlignFile = new CMAlignFile;
	if((Rslt = pAlignFile->Open(pszBioSeqFile))!=eBSFSuccess)
		{
		while(pAlignFile->NumErrMsgs())
			gDiagnostics.DiagOut(eDLFatal,gszProcName,pAlignFile->GetErrMsg());

		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open %s",pszBioSeqFile);
		delete pAlignFile;
		return(Rslt);
		}

	int NumSpecies = pAlignFile->GetNumSpecies();
	for(CurEntryID = 1; CurEntryID <= NumSpecies; CurEntryID++)
		{
		pszSpeciesName = pAlignFile->GetSpeciesName(CurEntryID);
		WriteDumpFile(CurEntryID,pszSpeciesName,NULL,0,NULL);
		}
	Rslt = CurEntryID == NumSpecies ? eBSFSuccess : eBSFerrInternal;
	}
else
	{
	while((CurEntryID = pBioSeqFile->Next(CurEntryID)) > 0 )
		{
		pBioSeqFile->GetNameDescription(CurEntryID,cBSFSourceSize-1,(char *)&szSource,
								cBSFDescriptionSize-1,(char *)&szDescription);
		SeqLen = pBioSeqFile->GetDataLen(CurEntryID);
		if(m_FMode == eFMdefault)
			{
			if(m_pSeq == NULL || m_AllocSeqLen == 0 || SeqLen >= (int)m_AllocSeqLen)
				{
				if(m_pSeq != NULL)
					{
					delete m_pSeq;
					m_pSeq = NULL;
					m_AllocSeqLen = 0;
					}
				m_AllocSeqLen = SeqLen + 100000;
				if((m_pSeq = new UINT8 [m_AllocSeqLen])==NULL)
					{
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate %d memory",m_AllocSeqLen);
					return(eBSFerrMem);
					}
				}

			pBioSeqFile->GetData(CurEntryID,eAsciiType,0,m_pSeq,SeqLen);
			}

		WriteDumpFile(CurEntryID,szSource,szDescription,SeqLen,m_pSeq);
		}
	Rslt = CurEntryID == eBSFerrEntry ? eBSFSuccess : (int)CurEntryID;
	}
CloseDumpFile();
if(pBioSeqFile != NULL)
	delete pBioSeqFile;
if(pAlignFile != NULL)
	delete pAlignFile;
if(m_pSeq != NULL)
	delete m_pSeq;
return(Rslt);
}



// MakeXMLsafe
// Replaces any chars which may cause XML to baff with a safe character '.'
char *
MakeXMLsafe(char *pszStr)
{
char *pszTrans = pszStr;
char Chr;

while(Chr=*pszStr++)
	{
	switch(Chr) {
		case '&':
		case '<':
		case '>':
			pszStr[-1] = '.';
		default:
			continue;
		}
	}
return(pszTrans);
}
bool 
WriteDumpFile(int EntryID,char *pszSource,char *pszDescr,int DataLen,UINT8 *pszSeq)
{
char szBuff[cBSFSourceSize+cBSFDescriptionSize+1000];
int Len;
int LineLen;
UINT8 Base;

if(pszDescr == NULL)
	pszDescr = (char *)"none";

switch(m_FMode) {
	case eFMdefault:				// default is for multifasta
		Len = sprintf(szBuff,">%s\n",pszDescr);
		while(DataLen > 0)
			{
			if((Len + 200) > sizeof(szBuff))
				{
				CUtility::SafeWrite(hDumpFile,szBuff,Len);
				Len = 0;
				}
			LineLen = min(79,DataLen);
			Base = pszSeq[LineLen];
			pszSeq[LineLen] = '\0';
			Len += sprintf(&szBuff[Len],"%s\n",pszSeq);
			pszSeq += LineLen;
			*pszSeq = Base;
			DataLen -= LineLen;
			}
		break;

	case eFMcsv:					// CSV entries
		Len = sprintf(szBuff,"%d,\"%s\",\"%s\",%d\n",
				EntryID,
				MakeXMLsafe(pszSource),
				MakeXMLsafe(pszDescr),
				DataLen);
		break;

	
	case eFMbed:					// BED entries
		Len = sprintf(szBuff,"%s\t0\t%d\tContig_%d\t0\t%c\n",
			    MakeXMLsafe(pszSource),DataLen,EntryID,'+');
		break;

	case eFMxml:					// XML entries	
		Len = sprintf(szBuff,"\n<entry>\n<id>%d</id>\n<src>%s</src>\n<descr>%s</descr>\n<len>%d</len>\n</entry>",
				EntryID,
				MakeXMLsafe(pszSource),
				MakeXMLsafe(pszDescr),
				DataLen);
		break;
	}
if(Len > 0)
	return(CUtility::SafeWrite(hDumpFile,szBuff,Len));
return(true);
}

bool 
OpenDumpFile(char *pszDumpFile) // specifies file to create
{
char szBuff[2000];
int Len;

#ifdef _WIN32
if((hDumpFile = open(pszDumpFile, _O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE ))==-1)
#else
if((hDumpFile = open(pszDumpFile,O_RDWR | O_CREAT |O_TRUNC, S_IREAD | S_IWRITE ))==-1)
#endif
	{
	printf("OpenDumpFile: Unable to create or truncate  dump file %s error: %s",pszDumpFile,strerror(errno));
	return(false);
	}
if(m_FMode != eFMxml)
	return(true);

Len = sprintf(szBuff,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
Len+= sprintf(&szBuff[Len],"<root xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:od=\"urn:schemas-microsoft-com:officedata\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:schema>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element name=\"dataroot\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:complexType>\n");
Len+= sprintf(&szBuff[Len],"<xsd:sequence>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element ref=\"entry\" minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n");
Len+= sprintf(&szBuff[Len],"</xsd:sequence>\n");
Len+= sprintf(&szBuff[Len],"<xsd:attribute name=\"generated\" type=\"xsd:dateTime\"/>\n");
Len+= sprintf(&szBuff[Len],"</xsd:complexType>\n");
Len+= sprintf(&szBuff[Len],"</xsd:element>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element name=\"entry\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:annotation>\n");
Len+= sprintf(&szBuff[Len],"<xsd:appinfo/>\n");
Len+= sprintf(&szBuff[Len],"</xsd:annotation>\n");
Len+= sprintf(&szBuff[Len],"<xsd:complexType>\n");
Len+= sprintf(&szBuff[Len],"<xsd:sequence>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element name=\"id\" minOccurs=\"1\" od:jetType=\"integer\" od:sqlSType=\"smallint\" od:nonNullable=\"yes\" type=\"xsd:short\"/>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element name=\"src\" minOccurs=\"0\" od:jetType=\"text\" od:sqlSType=\"nvarchar\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:simpleType>\n");
Len+= sprintf(&szBuff[Len],"<xsd:restriction base=\"xsd:string\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:maxLength value=\"255\"/>\n");
Len+= sprintf(&szBuff[Len],"</xsd:restriction>\n");
Len+= sprintf(&szBuff[Len],"</xsd:simpleType>\n");
Len+= sprintf(&szBuff[Len],"</xsd:element>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element name=\"descr\" minOccurs=\"0\" od:jetType=\"text\" od:sqlSType=\"nvarchar\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:simpleType>\n");
Len+= sprintf(&szBuff[Len],"<xsd:restriction base=\"xsd:string\">\n");
Len+= sprintf(&szBuff[Len],"<xsd:maxLength value=\"255\"/>\n");
Len+= sprintf(&szBuff[Len],"</xsd:restriction>\n");
Len+= sprintf(&szBuff[Len],"</xsd:simpleType>\n");
Len+= sprintf(&szBuff[Len],"</xsd:element>\n");
Len+= sprintf(&szBuff[Len],"<xsd:element name=\"len\" minOccurs=\"1\" od:jetType=\"longinteger\" od:sqlSType=\"int\" od:nonNullable=\"yes\" type=\"xsd:int\"/>\n");
Len+= sprintf(&szBuff[Len],"</xsd:sequence>\n");
Len+= sprintf(&szBuff[Len],"</xsd:complexType>\n");
Len+= sprintf(&szBuff[Len],"</xsd:element>\n");
Len+= sprintf(&szBuff[Len],"</xsd:schema>\n");


struct tm *newtime;
time_t aclock;
time(&aclock );   // Get time in seconds
newtime = localtime( &aclock );   // Convert time to struct tm form 

Len+= sprintf(&szBuff[Len],"<dataroot xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" generated=\"%24.24s\">",asctime( newtime ));
CUtility::SafeWrite(hDumpFile,szBuff,Len);
return(true);
}

bool 
CloseDumpFile(void)				// closes opened dump file
{
int Len;
char szBuff[100];
if(hDumpFile == -1)
	return(false);
if(m_FMode == eFMxml)
	{
	Len = sprintf(szBuff,"\n</dataroot>\n</root>");
	CUtility::SafeWrite(hDumpFile,szBuff,Len);
	}
close(hDumpFile);
hDumpFile = -1;
return(true);
}
