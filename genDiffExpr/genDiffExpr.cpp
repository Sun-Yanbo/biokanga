// genDiffExpr.cpp : Defines the entry point for the console application.
// Purpose -
// Loads the output generated by maploci2features processing with '-o<featuremapfile>' and identifies the differentially expressed transcripts
//
#include "stdafx.h"

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if _WIN32
#include <process.h>
#include "../libbiokanga/commhdrs.h"
#else
#include <sys/mman.h>
#include <pthread.h>
#include "../libbiokanga/commhdrs.h"
#endif

const char *cpszProgVer = "1.0.5";			// increment with each release

const double cNormCntsScale = 1.0;			// default normalise experiment to control counts by scaling with this multiplier


const int cMaxInFileSpecs = 10;				// allow at most this many wildcarded control or experiment input read alignment loci files

const int cWrtBuffSize = 0x03fffff;			// use a 16 MB write buffer size

const int cAlignHitsInitalAlloc   = 20000000;	// initial allocation to hold this many read alignments
const int cAlignHitsReAlloc		  = 10000000;	// realloc read alignments allocation in this sized increments

const int cAlignBinsInitalAlloc= 5000;	    // initial allocation to hold this many transcript read cnt bins
const int cAlignBinsReAlloc	   = 2500;		// realloc transcript read cnt bins allocation in these sized increments

const int cMaxNumAlignBins = 1000;			// default number of bins when calculating confidence intervals
const int cMaxNumPearsons = 10000;			// default number of Pearsons when calculating confidence intervals

// processing modes
typedef enum TAG_ePMode {
	ePMstarts = 0,				// default is for processing with counts representing alignment read start depths
	ePMcoverage,				// alternative is for processing with counts representing alignment coverage depths
	ePMplaceholder				// used to set the enumeration range
	} etPMode;

// analytics test to use
typedef enum TAG_etATest {
	eATMannWhitney = 0,			// default is for Mann-Whitney
	eATWilcoxon,				// Wilcoxon signed rank
	eATplaceholder				// used to set the enumeration range
	} etATest;

typedef enum eBEDRegion {
	eMEGRAny = 0,				// process any region
	eMEGRIntergenic,			// only process intergenic
	eMEGRExons,					// only process exons
	eMEGRIntrons,				// only process introns
	eMEGRCDS,					// only process CDSs
	eMEGUTR,					// only process UTRs
	eMEG5UTR,					// only process 5'UTRs
	eMEG3UTR					// only process 3'UTRs
} etBEDRegion;

// strand processing modes
typedef enum TAG_eStrandProc {
		eStrandDflt,			// default is to ignore the strand
		eStrandWatson,			// process for Watson or sense
		eStrandCrick,			// process for Crick or antisense
		eStrandPlaceholder
} etStrandProc;

#pragma pack(1)

typedef struct TAG_sRefIDChrom {
	UINT32 ChromID;			// uniquely identifies chromosome
	UINT32 Hash;				// hash on chromosome name - GenHash()
	char szChromName[cMaxDatasetSpeciesChrom];	// chromosome name
} tsRefIDChrom;

typedef struct TAG_sAlignHit {
	UINT8 ExprFlag:1;			// 0 if aligned read from control, 1 if from experiment
	UINT32 AlignHitIdx;			// current read hit index + 1 for this read
	UINT32 Score;				// any score associated with this alignment
	UINT32 ChromID;				// identifies hit chromosome - ChromToID(pszChrom)
	UINT8 Strand;				// hit strand - '+' or '-'
	UINT32 Loci;				// offset on chromosome of hit
	UINT16 MatchLen;			// match or alignment length
} tsAlignHit;

typedef struct TAG_sAlignLociInstCnts {
	UINT32 Bin;					// instance counts are for this bin
	int    RelLoci;				// instance counts are at this loci
	UINT32 NumCtrlCnts;		// number of control start loci instances at this loci instance
	UINT32 NumExprCnts;		// number of experiment start loci instances  at this loci instance
} tsAlignLociInstCnts ;

typedef struct TAG_sAlignBinCnts {
	UINT32 Bin;					// counts are for this bin (1..n)
	UINT32 NumCtrlInsts;		// number of control start loci instances in this bin
	UINT32 NumExprInsts;		// number of experiment start loci instances in this bin
	UINT32 ControlSumCnts;		// number of counts for control
	UINT32 ExperimentSumCnts;	// unscaled number of counts for experiment
} tsAlignBinCnts;



typedef struct TAG_sRankedCnts {
	UINT8 ExprFlag:1;			// 0 if control, 1 if experiment has more
	double Value;				// absolute cnts if Mann-Whitney, or abs(difference between scaled experiment and control) if eATWilcoxon
	double Rank;				// associated ranking
} tsRankedCnts;

#pragma pack()

char *Region2Txt(etBEDRegion Region);
char ReportStrand(etStrandProc StrandProc);
void Reset(void);
void Init(void);

teBSFrsltCodes Process(etPMode PMode,					// processing mode
				    UINT32 LimitAligned,				// for test/evaluation can limit number of reads parsed to be no more than this number (0 for no limit)
					etATest ATest,						// analytics test to apply
					bool bFiltNonaligned,				// true if only features having at least one read aligned are to be be reported
					char AlignStrand,					// process for reads on this strand only
					char FeatStrand,					// process for genes or features on this strand only
					etBEDRegion Region,					// process for this genomic region only
					int	BinLen,							// if > 0 then number of non-overlapping count bins or if negative then non-overlapping bins of this length
					double NormCntsScale,				// counts normalisation scale factor
					int FType,							// input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM
					int NumInputControlSpecs,			// number of input file specs 
					char **pszInControlFiles,			// input control aligned reads files
					int NumInputExperimentSpecs,			// number of input file specs 
					char **pszInExperimentFiles,			// input experiment aligned reads files
					char *pszInFeatFile,				// input gene or feature BED file
					char *pszOutfile,					// output into this file
					char *pszBinCountsFile);			// output bin counts to this file

teBSFrsltCodes
LoadGeneFeatures(char Strand,			// features on this strand
				 char *pszInFeatFile);	// from this BED file

int
LoadAlignedReadFiles(char Strand,		// process for this strand '+' or '-' or for both '*'
			int FType,					// input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM
			int NumInputControlSpecs,	// number of input file specs 
			char **pszInControlFiles,	// input control aligned reads files
			int NumInputExperimentSpecs,// number of input file specs 
			char **pszInExperimentFiles);	// input experiment aligned reads files

teBSFrsltCodes
LoadAlignedReadsBED(bool bIsExperiment,		// false if control file, true if experiment
			char *pszInFile,
			char FiltStrand);

teBSFrsltCodes
LoadAlignedReadsCSV(bool bIsExperiment,		// false if control file, true if experiment
			char *pszInFile,
			char FiltStrand);

teBSFrsltCodes
GenRankedDiffList(char Strand,				// alignments must be to this strand
				  char *pszChrom,			// alignments are on this chrom
				  UINT32 StartLoci,			// must start on or after this loci
				  UINT32 EndLoci);			// must start on or before this loci

teBSFrsltCodes
GenRankedDiffListAlignDensity(char Strand,				// alignments must be to this strand
				  char *pszChrom,			// alignments are on this chrom
				  UINT32 StartLoci,			// must start on or after this loci
				  UINT32 EndLoci);			// must start on or before this loci

teBSFrsltCodes
GenRankedDiffListAlignStarts(char Strand,	// alignments must be to this strand
				  char *pszChrom,			// alignments are on this chrom
				  UINT32 StartLoci,			// must start on or after this loci
				  UINT32 EndLoci);			// must start on or before this loci


teBSFrsltCodes AddAlignDiffCnts(int RelLoci,			// relative loci from which these cnts were derived
				 int ControlCnts, // counts for control
				 int ExperimentCnts);		// counts for experiment

int AnalyticsTest(char *pszFeatName);

int ReportBinCounts(bool bGenPearsons,		// true if Pearsons to be generated, false if m_Pearsons already initialised with Pearsons
				char *pszFeatName);			// reporting is for this feature

int MannWhitney(char *pszFeatName);

int Wilcoxon(char *pszFeatName);

char *IDtoChrom(UINT32 ChromID);			// returns ptr to chrom for ChromID
UINT32 ChromToID(char *pszChrom);			// get unique chromosome identifier

double	poz (double	z);						/* returns cumulative probability from -oo to z */

static int SortAlignments(const void *arg1, const void *arg2);
static int RankSortCnts(const void *arg1, const void *arg2);
static int SortPearsons(const void *arg1, const void *arg2);

CStopWatch gStopWatch;
CDiagnostics gDiagnostics;				// for writing diagnostics messages to log file
char gszProcName[_MAX_FNAME];			// process name
bool gbActivity;						// used to determine if activity messages vi printf's can be used - output activity if eDLInfo or less

#ifdef _WIN32
// required by str library
#if !defined(__AFX_H__)  ||  defined(STR_NO_WINSTUFF)
HANDLE STR_get_stringres()
{
	return NULL;	//Works for EXEs; in a DLL, return the instance handle
}
#endif

const STRCHAR* STR_get_debugname()
{
	return _T("genDiffExpr");
}
// end of str library required code
#endif


#ifdef _WIN32
int _tmain(int argc, char* argv[])
{
// determine my process name
_splitpath(argv[0],NULL,NULL,gszProcName,NULL);
#else
int
main(int argc, const char** argv)
{
// determine my process name
CUtility::splitpath((char *)argv[0],NULL,gszProcName);
#endif
int iScreenLogLevel;		// level of file diagnostics
int iFileLogLevel;			// level of file diagnostics
char szLogFile[_MAX_PATH];	// write diagnostics to this file
int Rslt = 0;   			// function result code >= 0 represents success, < 0 on failure

int Idx;
etPMode PMode;				// processing mode
int FType;					// expected input element file type - auto, CSV, BED or SAM
etATest ATest;				// Analytics test to use
bool bFiltNonaligned;		// true if only features having at least one read aligned are to be be reported
etBEDRegion Region;			// process for this functional region only
double NormCntsScale;		// counts normalisation scale factor
int LimitAligned;			// for test/evaluation can limit number of reads parsed to be no more than this number (0 for no limit)
int BinLen;					// bin cnts into non-overlapping bins of this length 

etStrandProc AlignStrand;			// process for reads on this strand only
etStrandProc FeatStrand;			// process for genes or features on this strand only


int NumInputControlSpecs;			// number of input file specs 
char *pszInControlFiles[cMaxInFileSpecs];			// input control aligned reads files
int NumInputExperimentSpecs;		// number of input file specs 
char *pszInExperimentFiles[cMaxInFileSpecs];		// input experiment aligned reads files

char szInFeatFile[_MAX_PATH];        // input genes or features BED file
char szOutfile[_MAX_PATH];			 // output file
char szBinCountsFile[_MAX_PATH];	 // output file for bin counts


// command line args
struct arg_lit  *help    = arg_lit0("hH","help",                "print this help and exit");
struct arg_lit  *version = arg_lit0("v","version,ver",			"print version information and exit");
struct arg_int *FileLogLevel=arg_int0("f", "FileLogLevel",		"<int>","Level of diagnostics written to screen and logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
struct arg_file *LogFile = arg_file0("F","log","<file>",		"diagnostics log file");

struct arg_int *pmode = arg_int0("m","mode","<int>",		    "processing mode: 0 - aligned read start loci, 1 - aligned read coverage");
struct arg_int *atest = arg_int0("a","mode","<int>",			"analytics test: 0 - Mann-Whitney, 1 - Wilcoxon signed rank (default 0)");
struct arg_int *region = arg_int0("r","region","<int>",		    "process region: 0 - all except intergenic, 1: Intergenic, 2: Exons, 3:Introns, 4:CDSs, 5:UTRs, 6:5'UTRs, 7:3'UTRs (default 2 Exons)");
struct arg_lit  *filtnonaligned = arg_lit0("A","nonalign",		"do not report on features which have no aligned reads");

struct arg_dbl *normcntsscale = arg_dbl0("n","mode","<dbl>",	"control counts normalisation scale factor 0.1 to 10.0 (default is 0 for auto-library size normalisation)");

struct arg_int  *alignstrand = arg_int0("s","alignstrand","<int>","read alignment strand processing: 0 - independent, 1 - sense, 2 - antisense (default is independent)");
struct arg_int  *featstrand = arg_int0("S","featstrand","<int>","gene or feature strand processing: 0 - independent, 1 - sense, 2 - antisense (default is independent)");
struct arg_int  *binlen = arg_int0("b","binlen","<int>",		"bin counts for each gene/feature into this many non-overlapping bins (3 to 100, defaults to 20), if negative then specifies absolute sized bins in bp (1 to 100)");
struct arg_int  *limitaligned = arg_int0("L","limitaligned","<int>","for test/evaluation can limit number of reads parsed to be no more than this number (default 0 for no limit)");

struct arg_int *ftype = arg_int0("t","filetype","<int>",		"input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM (default = 0)");

struct arg_file *incontrolfiles = arg_filen("i","control","<file>",1,cMaxInFileSpecs, "input control read alignments files (wildcards allowed)");
struct arg_file *inexperfiles = arg_filen("I","experiment","<file>",1,cMaxInFileSpecs,"input experiment read alignments file (wildcards allowed)");
struct arg_file *infeatfile = arg_file1("g","ingene","<file>",	   "input gene or feature biobed BED file");

struct arg_file *outfile = arg_file1("o","out","<file>",		"output transcript differentials to this file as CSV");
struct arg_file *bincountsfile = arg_file0("O","bincounts","<file>","output transcript bin counts to this file as CSV");

struct arg_end *end = arg_end(20);

void *argtable[] = {help,version,FileLogLevel,LogFile,
					pmode,ftype,filtnonaligned,limitaligned,atest,alignstrand,featstrand,region,normcntsscale,binlen,incontrolfiles,inexperfiles,outfile,bincountsfile,infeatfile,
					end};

char **pAllArgs;
int argerrors;
argerrors = CUtility::arg_parsefromfile(argc,(char **)argv,&pAllArgs);
if(argerrors >= 0)
	argerrors = arg_parse(argerrors,pAllArgs,argtable);

/* special case: '--help' takes precedence over error reporting */
if (help->count > 0)
        {
		printf("\n%s process for differentially expressed transcripts, Version %s\nOptions ---\n", gszProcName,cpszProgVer);
        arg_print_syntax(stdout,argtable,"\n");
        arg_print_glossary(stdout,argtable,"  %-25s %s\n");
		printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
		printf("\n      To invoke this parameter file then precede it's name with '@'");
		printf("\n      e.g. %s @myparams.txt\n",gszProcName);
		printf("\nPlease report any issues regarding usage of %s to stuart.stephen@csiro.au\n\n",gszProcName);
		exit(1);
        }

    /* special case: '--version' takes precedence error reporting */
if (version->count > 0)
        {
		printf("\n%s Version %s\n",gszProcName,cpszProgVer);
		exit(1);
        }

if (!argerrors)
	{
	gbActivity = true;
	if(FileLogLevel->count && !LogFile->count)
		{
		printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>'",FileLogLevel->ival[0]);
		exit(1);
		}

	iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
	if(iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
		printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d",iFileLogLevel,eDLNone,eDLDebug);
		exit(1);
		}
	if(LogFile->count)
		{
		strncpy(szLogFile,LogFile->filename[0],_MAX_PATH);
		szLogFile[_MAX_PATH-1] = '\0';
		}
	else
		{
		iFileLogLevel = eDLNone;
		szLogFile[0] = '\0';
		}

	PMode = (etPMode)(pmode->count ? pmode->ival[0] : ePMstarts);
	if(PMode < ePMstarts || PMode >= ePMplaceholder)
		{
		printf("\nError: Processing mode '-m%d' specified outside of range %d..%d",PMode,0,(int)ePMplaceholder-1);
		exit(1);
		}

	FType = ftype->count ? ftype->ival[0] : 0;
	if(FType < 0 || FType >= 4)
		{
		printf("\nError: Expected input element file format '-t%d' specified outside of range %d..%d",FType,0,3);
		exit(1);
		}

	ATest = (etATest)(atest->count ? atest->ival[0] : eATMannWhitney);
	if(ATest < eATMannWhitney || ATest >= eATplaceholder)
		{
		printf("\nError: Analytics test '-a%d' specified outside of range %d..%d",ATest,eATMannWhitney,(int)eATplaceholder-1);
		exit(1);
		}

	bFiltNonaligned = filtnonaligned->count ? true : false;

	Region = (etBEDRegion)(region->count ? region->ival[0] : eMEGRExons);	// default as being exons
	if(Region < eMEGRAny || Region > eMEG3UTR)
		{
		printf("\nSpecified region '-g%d' outside of range 0..%d",Region,eMEG3UTR);
		exit(1);
		}

	AlignStrand = (etStrandProc)(alignstrand->count ? alignstrand->ival[0] : eStrandDflt);
	if(AlignStrand < eStrandDflt || AlignStrand >= eStrandPlaceholder)
		{
		printf("\nError: Alignment strand '-s%d' must be in range %d..%d",AlignStrand,eStrandDflt,eStrandCrick);
		exit(1);
		}

	FeatStrand = (etStrandProc)(alignstrand->count ? alignstrand->ival[0] : eStrandDflt);
	if(FeatStrand < eStrandDflt || FeatStrand >= eStrandPlaceholder)
		{
		printf("\nError: Feature strand '-S%d' must be in range %d..%d",FeatStrand,eStrandDflt,eStrandCrick);
		exit(1);
		}

	LimitAligned = limitaligned->count ? limitaligned->ival[0] : 0;
	if(LimitAligned < 0)
		{
		printf("\nError: Limit on aligned reads processed '-L%d' must be >= 0",LimitAligned);
		exit(1);
		}

	BinLen = binlen->count ? binlen->ival[0] : 20;
	if(BinLen == 0)
		BinLen = 20;
	if(BinLen < 0)		// negative values representing absolute bin sizes must be in range -1..-100
		{
		if(BinLen < -100)
			{
			printf("\nError: Bin absolute length '-b%d' must be in range 1..100",BinLen);
			exit(1);
			}
		}
	else
		if(BinLen < 3)	// positive if number of bins per counted region
			{
			printf("\nError: Number of bins '-b%d' must be in range of 3 to 100",BinLen);
			exit(1);
			}

	NormCntsScale = (double)(normcntsscale->count ? normcntsscale->dval[0] : 0.0);
	if(NormCntsScale != 0.0 && (NormCntsScale < 0.1 || NormCntsScale >= 10.0))
		{
		printf("\nError: Manual override counts normalisation scale factor '-m%f' specified outside of range %f..%f",NormCntsScale,0.1,10.0);
		exit(1);
		}

	for(NumInputControlSpecs=Idx=0;NumInputControlSpecs < cMaxInFileSpecs && Idx < incontrolfiles->count; Idx++)
		{
		pszInControlFiles[Idx] = NULL;
		if(pszInControlFiles[NumInputControlSpecs] == NULL)
			pszInControlFiles[NumInputControlSpecs] = new char [_MAX_PATH];
		strncpy(pszInControlFiles[NumInputControlSpecs],incontrolfiles->filename[Idx],_MAX_PATH);
		pszInControlFiles[NumInputControlSpecs][_MAX_PATH-1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(pszInControlFiles[NumInputControlSpecs]);
		if(pszInControlFiles[NumInputControlSpecs][0] != '\0')
			NumInputControlSpecs++;
		}

	if(!NumInputControlSpecs)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: After removal of whitespace, no input file(s) specified with '-i<filespec>' option)\n");
		exit(1);
		}

	for(NumInputExperimentSpecs=Idx=0;NumInputExperimentSpecs < cMaxInFileSpecs && Idx < inexperfiles->count; Idx++)
		{
		pszInExperimentFiles[Idx] = NULL;
		if(pszInExperimentFiles[NumInputExperimentSpecs] == NULL)
			pszInExperimentFiles[NumInputExperimentSpecs] = new char [_MAX_PATH];
		strncpy(pszInExperimentFiles[NumInputExperimentSpecs],inexperfiles->filename[Idx],_MAX_PATH);
		pszInExperimentFiles[NumInputExperimentSpecs][_MAX_PATH-1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(pszInExperimentFiles[NumInputExperimentSpecs]);
		if(pszInExperimentFiles[NumInputExperimentSpecs][0] != '\0')
			NumInputExperimentSpecs++;
		}

	if(!NumInputExperimentSpecs)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: After removal of whitespace, no input file(s) specified with '-I<filespec>' option)\n");
		exit(1);
		}


	strcpy(szInFeatFile,infeatfile->filename[0]);			// input genes or features BED file
	strcpy(szOutfile,outfile->filename[0]);					// output file

	if(bincountsfile->count > 0)
		strcpy(szBinCountsFile,bincountsfile->filename[0]);	
	else
		szBinCountsFile[0] = '\0';

			// now that command parameters have been parsed then initialise diagnostics log system
	if(!gDiagnostics.Open(szLogFile,(etDiagLevel)iScreenLogLevel,(etDiagLevel)iFileLogLevel,true))
		{
		printf("\nError: Unable to start diagnostics subsystem.");
		if(szLogFile[0] != '\0')
			printf(" Most likely cause is that logfile '%s' can't be opened/created",szLogFile);
		exit(1);
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Version: %s Processing parameters:",cpszProgVer);

	const char *pszProcMode;
	switch(PMode) {
		case ePMcoverage:
			pszProcMode = "Cnts from aligned reads coverage";
			break;
		case ePMstarts:
			pszProcMode = "Cnts from aligned read starts";
			break;
		default:
			pszProcMode = "Unknown mode, defaulting Standard processing";
			PMode = ePMstarts;
			break;
		};
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Processing mode: '%s'",pszProcMode);

	switch(ATest) {
		case eATMannWhitney:
			pszProcMode = "Mann-Whitney";
			break;
		case eATWilcoxon:
			pszProcMode = "Wilcoxon signed rank";
			break;
		default:
			pszProcMode = "Unknown mode, defaulting to Mann-Whitney";
			ATest = eATMannWhitney;
			break;
		};
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Analytics test: '%s'",pszProcMode);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Report to include features to which no reads align: '%s'",bFiltNonaligned ? "No" : "Yes");

	if(LimitAligned > 0)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Process at most this number of aligned reads: %d",LimitAligned);
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Process at most this number of aligned reads: No Limit");

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Process aligned reads strand: '%c'",ReportStrand(AlignStrand));

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Process gene or feature strand: '%c'",ReportStrand(FeatStrand));

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Process cnts in region: %s",Region2Txt((etBEDRegion)Region));

	if(BinLen < 0)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Bin cnts into non-overlapping bins of this length: %d",abs(BinLen));
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Bin cnts into this many non-overlapping bins: %d",BinLen);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Control counts normalisation scale factor: %0.3f",NormCntsScale);

		switch(FType) {
		case 0:
			gDiagnostics.DiagOutMsgOnly(eDLInfo,"Auto-classify input element file as either CSV, BED or SAM");
			break;

		case 1:
			gDiagnostics.DiagOutMsgOnly(eDLInfo,"Expecting input element file to be CSV format");
			break;

		case 2:
			gDiagnostics.DiagOutMsgOnly(eDLInfo,"Expecting input element file to be BED format");
			break;

		case 3:
			gDiagnostics.DiagOutMsgOnly(eDLInfo,"Sorry, SAM format processing has not been implemented");
			exit(1);
		}
	
	for(Idx=0; Idx < NumInputControlSpecs; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"input control aligned reads file (%d): '%s'",Idx+1,pszInControlFiles[Idx]);
	for(Idx=0; Idx < NumInputExperimentSpecs; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"input control aligned reads file (%d): '%s'",Idx+1,pszInExperimentFiles[Idx]);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"input gene or feature BED file: '%s'", szInFeatFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"output file to create: '%s'", szOutfile);
	if(szBinCountsFile[0] != '\0')
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"write transcript bin counts to file: '%s'", szBinCountsFile);

#ifdef _WIN32
	SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
#endif
	gStopWatch.Start();
	Rslt = Process(PMode,						// processing mode
					LimitAligned,				// for test/evaluation can limit number of reads parsed to be no more than this number (0 for no limit)
					ATest,						// analytics test to apply
					bFiltNonaligned,			// true if only features having at least one read aligned are to be be reported
					ReportStrand(AlignStrand),	// process for reads on this strand only
					ReportStrand(FeatStrand),	// process for genes or features on this strand only
					Region,						// which genomic region is to be processed
					BinLen,						// if > 0 then number of non-overlapping count bins or if negative then non-overlapping bins of this length
					NormCntsScale,				// counts normalisation scale factor
					FType,						// input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM
					NumInputControlSpecs,		// number of input file specs 
					pszInControlFiles,			// input control aligned reads files
					NumInputExperimentSpecs,	// number of input file specs 
					pszInExperimentFiles,		// input experiment aligned reads files
					szInFeatFile,				// input gene or feature BED file
					szOutfile,					// output into this file
					szBinCountsFile);			// output bin counts to this file
	gStopWatch.Stop();
	Rslt = Rslt >=0 ? 0 : 1;
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Exit code: %d Total processing time: %s",Rslt,gStopWatch.Read());
	exit(Rslt);
	}
else
	{
	printf("\n%s genDiffExpr, Version %s\n", gszProcName,cpszProgVer);
	arg_print_errors(stdout,end,gszProcName);
	arg_print_syntax(stdout,argtable,"\nUse '-h' to view option and parameter usage\n");
	exit(1);
	}
return 0;
}

char *
Region2Txt(etBEDRegion Region)
{
switch(Region) {
	case eMEGRAny:		// process any region
		return((char *)"All except Intergenic");

	case eMEGRIntergenic:	// only process intergenic
		return((char *)"Intergenic");

	case eMEGRExons:	// only process exons
		return((char *)"EXONS");

	case eMEGRIntrons:	// only process introns
		return((char *)"INTRONS");

	case eMEGRCDS:		// only process CDSs
		return((char *)"CDS");

	case eMEGUTR:		// only process UTRs
		return((char *)"UTR");

	case eMEG5UTR:		// only process 5'UTRs
		return((char *)"5'UTR");

	case eMEG3UTR:		// only process 3'UTRs
		return((char *)"3'UTR");

	default:
		break;
	}
return((char *)"Unsupported");
}


char
ReportStrand(etStrandProc StrandProc)
{
static char Strand;

switch(StrandProc) {
	case eStrandDflt:
		Strand = '*';
		break;
	case eStrandWatson:
		Strand = '+';
		break;
	case eStrandCrick:			
		Strand = '-';
		break;
	}
return(Strand);
}

const int cDataBuffAlloc = 0x0fffffff;		// allocation size to hold features

etPMode m_PMode;					// processing mode
etATest m_ATest;					// analytics test to apply
bool m_bFiltNonaligned;				// true if only features having at least one read aligned are to be be reported

UINT32 m_LimitAligned;				// for test/evaluation can limit number of reads parsed to be no more than this number (0 for no limit)

double m_NormCntsScale;				// normalise the control counts by scaling with this factor

tsAlignHit *m_pAlignHits = NULL;	// memory allocated to hold reads, reads are written contiguously into this memory
UINT32 m_AllocdAlignHits;			// how instances of tsAlignHit have been allocated
UINT32 m_NumAlignHits;				// m_pAlignHits contains a total of this many reads
UINT32 m_ControlAlignedHits;		// of which these are from the control
UINT32 m_ExperimentAlignedHits;		// and these are from the experiment

tsAlignBinCnts *m_pAlignBins = NULL;	// memory allocated to hold alignment bin cnts
UINT32 m_AllocdAlignBins = 0;		// how instances of tsAlignBinCnts have been allocated
UINT32 m_NumAlignBins = 0;			// m_pAlignBins currently contains this many experiment and control differential instances

tsAlignLociInstCnts *m_pBinInstsCnts;	// pts to list of control and experiment start instance counts for all bins
UINT32 m_AllocBinInstCnts = 0;			// m_pBinInstsCnts is currently allocated to hold at most this number of start loci instance counts 
UINT32 m_NumBinInstCnts = 0;			// m_pBinInstsCnts currently contains this many experiment and control instance counts 

tsRankedCnts *m_pRankedCnts;		// counts as used in the analytics
UINT32 m_AllocdRankedCnts = 0;		// how instances of tsRankedCnts have been allocated
UINT32 m_NumRankedCnts = 0;			// number of tsRankedCnts instances used

UINT32 m_CurFeatLen;				// current feature length over which counts are being processed
UINT32 m_CurFeatCtrlCntsTotal;		// total control counts for current feature
UINT32 m_CurFeatExprCntsTotal;		// total experiment counts for current feature
double m_CurFoldChange;				// fold change relative to control

int m_BinLen;						// Bin cnts into non-overlapping bins of this length or if negative then this abs(value) many bins per region
int m_CurRegionLen;					// region length for curent gene or feature being processed 

double m_LibSizeNormExpToCtrl;		// factor by which experiment counts can be normalised to that of control counts (accounts for library size ratio)

CBEDfile *m_pBEDFeatFile;

size_t m_DataBuffLen = 0;			// total memory allocated 
size_t m_DataBuffOfs = 0;			// offset at which to next write

UINT8 *m_pWrtBuff;					// used to buffer output writes to file

int m_hOutFile;						// output results file
int m_hBinCountsFile;				// output bin counts file
bool m_bWrtBinHdr;					// true if bin counts file requires header row

tsAlignBinCnts *m_pPermAlignBinCnts;	// to hold counts whilst determining confidence interval
size_t m_AllocNumAlignBins;			// number allocated

CSimpleRNG m_SimpleRNG;				// used to generate Poisson distributed random cnts

double *m_pPearsons;				 // to hold Pearsons whilst determining confidence interval
size_t m_AllocNumPearsons;			 // number allocated
double m_Low95;						// lower 95% limit
double m_Up95;						// upper 95% limit
double m_Pearson;					// Pearson 
double m_PearsonMedian;				// Pearson median
double m_PearsonPValue;				// proportion greater than Pearson

tsRefIDChrom *m_pChroms = NULL;
int m_NumChromsAllocd = 0;
int m_CurNumChroms = 0;
int m_MRAChromID = 0;

void
Init(void)
{
m_pAlignHits = NULL;
m_pAlignBins = NULL;
m_pBinInstsCnts = NULL;
m_pRankedCnts = NULL;
m_pWrtBuff = NULL;
m_pChroms = NULL;
m_pBEDFeatFile = NULL;
m_pPermAlignBinCnts = NULL;
m_pPearsons = NULL;
m_hOutFile = -1;
m_hBinCountsFile = -1;
Reset();
}

void
Reset(void)
{
if(m_hOutFile != -1)
	{
#ifdef _WIN32
		_commit(m_hOutFile);
#else
		fsync(m_hOutFile);
#endif
	close(m_hOutFile);
	m_hOutFile = -1;
	}

if(m_hBinCountsFile != -1)
	{
#ifdef _WIN32
	_commit(m_hBinCountsFile);
#else
	fsync(m_hBinCountsFile);
#endif
	close(m_hBinCountsFile);
	m_hBinCountsFile = -1;
	}

if(m_pChroms != NULL)
	{
	delete m_pChroms;
	m_pChroms = NULL;
	}
if(m_pAlignHits != NULL)
	{
#ifdef _WIN32
	free(m_pAlignHits);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pAlignHits != MAP_FAILED)
		munmap(m_pAlignHits,m_AllocdAlignHits * sizeof(tsAlignHit));
#endif
	m_pAlignHits = NULL;
	}

if(m_pAlignBins != NULL)
	{
#ifdef _WIN32
	free(m_pAlignBins);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pAlignBins != MAP_FAILED)
		munmap(m_pAlignBins,m_AllocdAlignBins * sizeof(tsAlignBinCnts));
#endif
	m_pAlignBins = NULL;
	}

if(m_pBinInstsCnts != NULL)
	{
#ifdef _WIN32
	free(m_pBinInstsCnts);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pBinInstsCnts != MAP_FAILED)
		munmap(m_pBinInstsCnts,m_AllocBinInstCnts * sizeof(tsAlignLociInstCnts));
#endif
	m_pBinInstsCnts = NULL;
	}

if(m_pRankedCnts != NULL)
	{
#ifdef _WIN32
	free(m_pRankedCnts);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pRankedCnts != MAP_FAILED)
		munmap(m_pRankedCnts,m_AllocdRankedCnts * sizeof(tsRankedCnts));
#endif
	m_pRankedCnts = NULL;
	}

if(m_pPermAlignBinCnts != NULL)
	{
	delete m_pPermAlignBinCnts;
	m_pPermAlignBinCnts = NULL;
	}

if(m_pPearsons != NULL)
	{
	delete m_pPearsons;
	m_pPearsons = NULL;
	}

if(m_pBEDFeatFile != NULL)
	{
	delete m_pBEDFeatFile;
	m_pBEDFeatFile = NULL;
	}

if(m_pWrtBuff != NULL)
	{
	delete m_pWrtBuff;
	m_pWrtBuff = NULL;
	}
m_ATest = eATMannWhitney;
m_bFiltNonaligned = false;			
m_NumChromsAllocd = 0;
m_CurNumChroms = 0;
m_MRAChromID = 0;
m_NormCntsScale = cNormCntsScale;
m_AllocdAlignHits = 0;
m_NumAlignHits = 0;

m_AllocdAlignBins = 0;
m_NumAlignBins = 0;
m_AllocBinInstCnts = 0;
m_NumBinInstCnts = 0;

m_AllocdRankedCnts = 0;
m_NumRankedCnts = 0;
m_LimitAligned = 0;
m_LibSizeNormExpToCtrl = 1.0;
m_BinLen = 0;
m_CurRegionLen = 0;

m_AllocNumAlignBins = 0;
m_AllocNumPearsons = 0;

m_Low95 = 0.0;
m_Up95 = 0.0;
m_Pearson = 0.0; 
m_PearsonMedian = 0.0;
m_PearsonPValue = 0.0;
m_bWrtBinHdr = false;
}

teBSFrsltCodes 
Process(etPMode PMode,									// processing mode
				    UINT32 LimitAligned,				// for test/evaluation can limit number of reads parsed to be no more than this number (0 for no limit)
					etATest ATest,						// analytics test to apply
					bool bFiltNonaligned,				// true if only features having at least one read aligned are to be be reported
					char AlignStrand,					// process for reads on this strand only
					char FeatStrand,					// process for genes or features on this strand only
					etBEDRegion Region,					// process for this genomic region only
					int	BinLen,							// if > 0 then number of non-overlapping count bins or if negative then non-overlapping bins of this length
					double NormCntsScale,				// manual override counts normalisation scale factor
					int FType,							// input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM
					int NumInputControlSpecs,			// number of input file specs 
					char **pszInControlFiles,			// input control aligned reads files
					int NumInputExperimentSpecs,		// number of input file specs 
					char **pszInExperimentFiles,		// input experiment aligned reads files
					char *pszInFeatFile,				// input gene or feature BED file
					char *pszOutfile,					// output into this file
					char *pszBinCountsFile)				// output bin counts to this file
{
teBSFrsltCodes Rslt;

Init();
m_PMode = PMode;
m_ATest = ATest;
m_NormCntsScale = NormCntsScale;
m_BinLen = BinLen;
m_LimitAligned = LimitAligned;
m_bFiltNonaligned = bFiltNonaligned;

#ifdef _WIN32
if((m_hOutFile = open(pszOutfile, _O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE ))==-1)
#else
if((m_hOutFile = open(pszOutfile, O_RDWR | O_CREAT |O_TRUNC, S_IREAD | S_IWRITE))==-1)
#endif
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to create or truncate %s - %s",pszOutfile,strerror(errno));
	Reset();
	return(eBSFerrCreateFile);
	}

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Output results file created/truncated: '%s'",pszOutfile);

if(pszBinCountsFile != NULL && pszBinCountsFile[0] != '\0')
	{
#ifdef _WIN32
	if((m_hBinCountsFile = open(pszBinCountsFile, _O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE ))==-1)
#else
	if((m_hBinCountsFile = open(pszBinCountsFile, O_RDWR | O_CREAT |O_TRUNC, S_IREAD | S_IWRITE))==-1)
#endif
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to create or truncate %s - %s",pszBinCountsFile,strerror(errno));
		Reset();
		return(eBSFerrCreateFile);
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Output bin counts file created/truncated: '%s'",pszBinCountsFile);
	m_bWrtBinHdr = true;
	}
else
	m_hBinCountsFile = -1;


// load the aligned reads for both control and experiment
Rslt = (teBSFrsltCodes)LoadAlignedReadFiles(AlignStrand,FType,NumInputControlSpecs,pszInControlFiles,NumInputExperimentSpecs,pszInExperimentFiles);

if(NormCntsScale == 0.0)
	m_LibSizeNormExpToCtrl = (double)m_ControlAlignedHits/m_ExperimentAlignedHits;
else
	m_LibSizeNormExpToCtrl = NormCntsScale;

gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: ExprCnts: %d CtrlCnts: %d NormCntsScale: %f",m_ExperimentAlignedHits,m_ControlAlignedHits,NormCntsScale);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: Library size normalisation factor applied to experiment counts: %f",m_LibSizeNormExpToCtrl);

// load the gene or feature BED file
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading gene features from '%s'...",pszInFeatFile);
if((Rslt = (teBSFrsltCodes)LoadGeneFeatures(FeatStrand,pszInFeatFile))!=eBSFSuccess)
	{
	Reset();
	return(Rslt);
	}

// iterate features
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Iterating features and processing reads for differential expression...");

// for each feature, iterate the read alignments constructing a list for sorting
// the list elements consist of the absolute difference between read counts at each loci and if that difference was in the experiment or control 
int CurFeatureID;
int StartLoci;
int EndLoci;
int Score;
char szChrom[128];
char szFeatName[128];
char Strand;
int NumProcessed;
int IntergenicStart;
int	NumExons;
int	NumIntrons;			
int	CDSstart;
int	CDSend;
int Idx;

if(m_pAlignBins== NULL)
	{
	size_t memreq = cAlignBinsInitalAlloc * sizeof(tsAlignBinCnts);
#ifdef _WIN32
	m_pAlignBins = (tsAlignBinCnts *) malloc((size_t)memreq);	
	if(m_pAlignBins == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Memory allocation of %lld bytes failed",(INT64)memreq);
		Reset();
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pAlignBins = (tsAlignBinCnts *)mmap(NULL,(size_t)memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pAlignBins == MAP_FAILED)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Memory allocation of %lld bytes through mmap()  failed",(INT64)memreq,strerror(errno));
		m_pAlignBins = NULL;
		Reset();
		return(eBSFerrMem);
		}
#endif
	m_AllocdAlignBins = cAlignBinsInitalAlloc;
	m_NumAlignBins = 0;
	}


if(m_pBinInstsCnts== NULL)
	{
	size_t memreq = cAlignBinsInitalAlloc * sizeof(tsAlignLociInstCnts);
#ifdef _WIN32
	m_pBinInstsCnts = (tsAlignLociInstCnts *) malloc((size_t)memreq);	
	if(m_pBinInstsCnts == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Memory allocation of %lld bytes failed",(INT64)memreq);
		Reset();
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pBinInstsCnts = (tsAlignLociInstCnts *)mmap(NULL,(size_t)memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pBinInstsCnts == MAP_FAILED)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Memory allocation of %lld bytes through mmap()  failed",(INT64)memreq,strerror(errno));
		m_pBinInstsCnts = NULL;
		Reset();
		return(eBSFerrMem);
		}
#endif
	m_AllocBinInstCnts = cAlignBinsInitalAlloc;
	m_NumBinInstCnts = 0;
	}

if(m_pRankedCnts== NULL)
	{
	size_t memreq = cAlignBinsInitalAlloc * sizeof(tsRankedCnts);
#ifdef _WIN32
	m_pRankedCnts = (tsRankedCnts *) malloc((size_t)memreq);	
	if(m_pRankedCnts == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Memory allocation of %lld bytes failed",(INT64)memreq);
		Reset();
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pRankedCnts = (tsRankedCnts *)mmap(NULL,(size_t)memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pRankedCnts == MAP_FAILED)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Memory allocation of %lld bytes through mmap()  failed",(INT64)memreq,strerror(errno));
		m_pRankedCnts = NULL;
		Reset();
		return(eBSFerrMem);
		}
#endif
	m_AllocdRankedCnts = cAlignBinsInitalAlloc;
	m_NumRankedCnts = 0;
	}


#ifdef _DEBUG
#ifdef _WIN32
_ASSERTE( _CrtCheckMemory());
#endif
#endif

CurFeatureID = 0;
NumProcessed = 0;
IntergenicStart = 0;

unsigned long ThenSecs = gStopWatch.ReadUSecs();
unsigned long NowSecs = ThenSecs;
while(Rslt == eBSFSuccess && (CurFeatureID = m_pBEDFeatFile->GetNextFeatureID(CurFeatureID)) > 0)
	{
	NowSecs = gStopWatch.ReadUSecs();
	if(!(NumProcessed % 5000) || (NowSecs < ThenSecs) || (NowSecs - ThenSecs) > 30)
		{
		if(!NumProcessed)
			printf("\n     processing feature %9.9d",NumProcessed);
		else
			printf("\b\b\b\b\b\b\b\b\b%9.9d",NumProcessed);
		ThenSecs = NowSecs;
		}
	NumProcessed += 1;

	if((Rslt = m_pBEDFeatFile->GetFeature(CurFeatureID,// feature instance identifier
				szFeatName,				// where to return feature name
				szChrom,				// where to return chromosome name
				&StartLoci,				// where to return feature start on chromosome (0..n) 
				&EndLoci,				// where to return feature end on chromosome
 				&Score,					// where to return score
 				&Strand)) < eBSFSuccess)				// where to return strand
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Unexpected error returned from GetFeature: %d",Rslt);
		Reset();
		return(Rslt);
		}

	if(FeatStrand != '*' && Strand != FeatStrand)
		continue;


	m_NumAlignBins = 0;
	m_NumBinInstCnts = 0;
	m_CurFeatCtrlCntsTotal = 0;
	m_CurFeatExprCntsTotal = 0;
	m_CurFoldChange = 0.0;
	m_CurFeatLen = 0;

	if(Region != eMEGRAny)
		{
		NumExons = m_pBEDFeatFile->GetNumExons(CurFeatureID);					// returns number of exons - includes UTRs + CDS
		NumIntrons = m_pBEDFeatFile->GetNumIntrons(CurFeatureID);				
		CDSstart = StartLoci + m_pBEDFeatFile->GetCDSStart(CurFeatureID);		// returns relative start offset of CDS - NOTE add to '+' strand gene start, subtract on '-' strand gene start
		CDSend = StartLoci + m_pBEDFeatFile->GetCDSEnd(CurFeatureID);			// returns relative end offset of CDS - NOTE add to '+' strand gene start, subtract on '-' strand gene start
		}
	Rslt = eBSFSuccess;

	switch(Region) {
		case eMEGRAny:			// retain any region
			m_CurRegionLen = m_pBEDFeatFile->GetFeatLen(CurFeatureID);
			if(m_CurRegionLen > 0)
				Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
			break;

		case eMEGRIntergenic:	// only retain intergenic
			m_CurRegionLen = StartLoci - IntergenicStart;
			if(m_CurRegionLen > 0)
				{
				if(IntergenicStart < StartLoci)
					Rslt=GenRankedDiffList(AlignStrand,szChrom,IntergenicStart,StartLoci-1);
				if(IntergenicStart <= EndLoci)
					IntergenicStart = EndLoci+1;
				}
			break;

		case eMEGRExons:		// only retain exons
			m_CurRegionLen = m_pBEDFeatFile->GetTranscribedLen(CurFeatureID);
			if(m_CurRegionLen > 0)
				{
				for(Idx = 1; Idx <= NumExons; Idx++)
					{
					StartLoci = m_pBEDFeatFile->GetExonStart(CurFeatureID,Idx);
					EndLoci   = m_pBEDFeatFile->GetExonEnd(CurFeatureID,Idx);
					if(StartLoci <= EndLoci)
						Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
					}
				}
			break;

		case eMEGRIntrons:		// only retain introns
			if(NumIntrons)
				{
				m_CurRegionLen =  m_pBEDFeatFile->GetFeatLen(CurFeatureID);
				m_CurRegionLen -= m_pBEDFeatFile->GetTranscribedLen(CurFeatureID);
				if(m_CurRegionLen > 0)
					{
					for(Idx = 1; Idx <= NumIntrons; Idx++)
						{
						StartLoci = m_pBEDFeatFile->GetIntronStart(CurFeatureID,Idx);
						EndLoci = m_pBEDFeatFile->GetIntronEnd(CurFeatureID,Idx);
						if(StartLoci <= EndLoci)
							Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
						}
					}
				}
			break;

		case eMEGRCDS:			// only retain CDSs
			m_CurRegionLen = m_pBEDFeatFile->GetCDSLen(CurFeatureID);
			if(m_CurRegionLen > 0)
				{
				for(Idx = 1; Idx <= NumExons; Idx++)
					{
					StartLoci = m_pBEDFeatFile->GetExonStart(CurFeatureID,Idx);
					EndLoci   = m_pBEDFeatFile->GetExonEnd(CurFeatureID,Idx);
					if(EndLoci < CDSstart || StartLoci > CDSend)
						continue;
					if(StartLoci < CDSstart)
						StartLoci = CDSstart;
					if(EndLoci > CDSend)
						EndLoci = CDSend;
					if(StartLoci <= EndLoci)
						GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
					}
				}
			break;

		case eMEGUTR:			// only process UTRs - single exon may have both 5' and 3' UTRs
			m_CurRegionLen = m_pBEDFeatFile->Get5UTRLen(CurFeatureID);
			m_CurRegionLen += m_pBEDFeatFile->Get3UTRLen(CurFeatureID);
			if(m_CurRegionLen > 0)
				{
				for(Idx = 1; Idx <= NumExons; Idx++)
					{
					StartLoci = m_pBEDFeatFile->GetExonStart(CurFeatureID,Idx);
					EndLoci   = m_pBEDFeatFile->GetExonEnd(CurFeatureID,Idx);
					if(EndLoci <= CDSend && StartLoci >= CDSstart) // is exon CDS only?
						continue;

					// check if 5' UTR 
					if(StartLoci < CDSstart)
						{
						if(EndLoci >= CDSstart)
							Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,CDSstart-1);
						else
							Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
						}
					
					// check if 3'UTR
					if(EndLoci > CDSend)
						{
						if(StartLoci <= CDSend)
							StartLoci = CDSend+1;
						Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
						}
					}
				}
			break;

		case eMEG5UTR:			// only process 5'UTRs - strand sensitive
			m_CurRegionLen = m_pBEDFeatFile->Get5UTRLen(CurFeatureID);
			if(m_CurRegionLen > 0)
				{
				for(Idx = 1; Idx <= NumExons; Idx++)
					{
					StartLoci = m_pBEDFeatFile->GetExonStart(CurFeatureID,Idx);
					EndLoci   = m_pBEDFeatFile->GetExonEnd(CurFeatureID,Idx);
					if(EndLoci <= CDSend && StartLoci >= CDSstart) // is exon CDS only?
						continue;

					if(Strand != '-')
						{
						// check if 5' UTR on '+' strand 
						if(StartLoci < CDSstart)
							{
							if(EndLoci >= CDSstart)
								EndLoci = CDSstart - 1;
							}
						}
					else 
						{	
						// check if 5'UTR on '-' strand
						if(EndLoci > CDSend)
							{
							if(StartLoci <= CDSend)
								StartLoci = CDSend+1;
							}
						}
					Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
					}
				}
			break;

		case eMEG3UTR:			// only process 3'UTRs  - strand sensitive
			m_CurRegionLen = m_pBEDFeatFile->Get3UTRLen(CurFeatureID);
			if(m_CurRegionLen > 0)
				{
				for(Idx = 1; Idx <= NumExons; Idx++)
					{
					StartLoci = m_pBEDFeatFile->GetExonStart(CurFeatureID,Idx);
					EndLoci   = m_pBEDFeatFile->GetExonEnd(CurFeatureID,Idx);
					if(EndLoci <= CDSend && StartLoci >= CDSstart) // is exon CDS only?
						continue;

					if(Strand == '-')
						{
						// check if 3' UTR on '-' strand 
						if(StartLoci < CDSstart)
							{
							if(EndLoci >= CDSstart)
								EndLoci = CDSstart - 1;
							}
						}
					else 
						{	
						// check if 3'UTR on '+' strand
						if(EndLoci > CDSend)
							{
							if(StartLoci <= CDSend)
								StartLoci = CDSend+1;
							}
						}
					Rslt=GenRankedDiffList(AlignStrand,szChrom,StartLoci,EndLoci);
					}
				}
			break;

		}
		
	// have finished counts for complete gene region
	if(!m_bFiltNonaligned || m_NumAlignBins)
		{
		AnalyticsTest(szFeatName);
		m_CurFeatCtrlCntsTotal = 0;
		m_CurFeatExprCntsTotal = 0;
		m_CurFoldChange = 0.0;
		m_CurFeatLen = 0;
		}

	}
printf("\b\b\b\b\b\b\b\b\b%9.9d",NumProcessed);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing completed");


#ifdef _DEBUG
#ifdef _WIN32
_ASSERTE( _CrtCheckMemory());
#endif
#endif

Reset();	// will close output files

return(eBSFSuccess);
}



teBSFrsltCodes
LoadGeneFeatures(char Strand,			// features on this strand
				 char *pszInFeatFile)	// from this BED file
{
teBSFrsltCodes Rslt;


if((m_pBEDFeatFile = new CBEDfile)==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CBEDfile");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt=m_pBEDFeatFile->Open(pszInFeatFile,eBTAnyBed)) !=eBSFSuccess)
	{
	while(m_pBEDFeatFile->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pBEDFeatFile->GetErrMsg());
	Reset();
	return(eBSFerrOpnFile);
	}

return(eBSFSuccess);
}

tsAlignLociInstCnts *
UpdateBinInstCnts(UINT32 Bin,int RelLoci,UINT32 CtrlCnts,UINT32 ExprCnts)
{
size_t memreq;
tsAlignLociInstCnts *pInstCnts;
int Idx;
pInstCnts = m_pBinInstsCnts;
if(m_NumBinInstCnts)
	{
	for(Idx = 0; Idx < (int)m_NumBinInstCnts; Idx++,pInstCnts++)
		if(pInstCnts->RelLoci == RelLoci && pInstCnts->Bin == Bin)
			{
			pInstCnts->NumCtrlCnts += CtrlCnts;
			pInstCnts->NumExprCnts += ExprCnts;
			return(pInstCnts);
			}
	}

if(m_AllocBinInstCnts == m_NumBinInstCnts)
	{
	// need to allocate more memory?
	if((m_NumAlignBins+10) >= m_AllocdAlignBins)
		{
		memreq = (m_NumAlignBins + cAlignBinsReAlloc) * sizeof(tsAlignBinCnts);
#ifdef _WIN32
		pInstCnts = (tsAlignLociInstCnts *) realloc(m_pAlignBins,memreq);
#else
		pInstCnts = (tsAlignLociInstCnts *)mremap(m_pAlignBins,m_AllocBinInstCnts *  sizeof(tsAlignLociInstCnts),memreq,MREMAP_MAYMOVE);
		if(pInstCnts == MAP_FAILED)
			pInstCnts = NULL;
#endif
		if(pInstCnts == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddAlignDiffCnts: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
			Reset();
			return(NULL);
			}
		m_pBinInstsCnts = (tsAlignLociInstCnts *)pInstCnts;
		m_AllocBinInstCnts += cAlignBinsReAlloc;
		}
	}
pInstCnts = &m_pBinInstsCnts[m_NumBinInstCnts++];
memset(pInstCnts,0,sizeof(tsAlignLociInstCnts));
pInstCnts->RelLoci = RelLoci;
pInstCnts->Bin = Bin;
pInstCnts->NumCtrlCnts = CtrlCnts;
pInstCnts->NumExprCnts = ExprCnts;
return(pInstCnts);
}

teBSFrsltCodes
AddAlignDiffCnts(int RelLoci,			// relative loci from which these cnts were derived
			int ControlCnts, int ExperimentCnts)
{
size_t memreq;
UINT8 *pTmpAlloc;
tsAlignBinCnts *pAlignCnts;
tsAlignLociInstCnts *pAlignLociInstCnts;
int CurBin;
UINT32 BinIdx;

// need to allocate more memory?
if((m_NumAlignBins+10) >= m_AllocdAlignBins)
	{
	memreq = (m_NumAlignBins + cAlignBinsReAlloc) * sizeof(tsAlignBinCnts);
#ifdef _WIN32
	pTmpAlloc = (UINT8 *) realloc(m_pAlignBins,memreq);
#else
	pTmpAlloc = (UINT8 *)mremap(m_pAlignBins,m_AllocdAlignBins *  sizeof(tsAlignBinCnts),memreq,MREMAP_MAYMOVE);
	if(pTmpAlloc == MAP_FAILED)
		pTmpAlloc = NULL;
#endif
	if(pTmpAlloc == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddAlignDiffCnts: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
		Reset();
		return(eBSFerrMem);
		}
	m_pAlignBins = (tsAlignBinCnts *)pTmpAlloc;
	m_AllocdAlignBins += cAlignBinsReAlloc;
	}

if(m_BinLen < 0)
	CurBin = RelLoci / abs(m_BinLen);
else
	CurBin = min(m_BinLen-1,(RelLoci * m_BinLen) / m_CurRegionLen);

// reads may be in any order so bin may have been previously allocated
// iterate any existing bins and check; update, insert new bin or append as may be appropriate
pAlignCnts = m_pAlignBins;
pAlignLociInstCnts = m_pBinInstsCnts;
if(m_NumAlignBins == 0)		// first bin for current feature?
	{
	memset(pAlignCnts,0,sizeof(tsAlignBinCnts));
	m_NumAlignBins = 1;
	pAlignCnts->ControlSumCnts = ControlCnts;
	pAlignCnts->ExperimentSumCnts = ExperimentCnts;
	if(ControlCnts > 0)
		pAlignCnts->NumCtrlInsts = 1;
	else
		pAlignCnts->NumCtrlInsts = 0;
	if(ExperimentCnts > 0)
		pAlignCnts->NumExprInsts = 1;
	else
		pAlignCnts->NumExprInsts = 0;
	pAlignCnts->Bin = CurBin+1;
	m_NumBinInstCnts = 0;
	UpdateBinInstCnts(pAlignCnts->Bin,RelLoci,ControlCnts,ExperimentCnts);
	return(eBSFSuccess);
	}

// at least one bin already for this feature...
for(BinIdx = 0; BinIdx < m_NumAlignBins; BinIdx++, pAlignCnts++)
	{
	if(pAlignCnts->Bin == (CurBin+1))  // existing bin?
		{
		pAlignCnts->ControlSumCnts += ControlCnts;
		pAlignCnts->ExperimentSumCnts += ExperimentCnts;
		if(ControlCnts > 0)
			pAlignCnts->NumCtrlInsts += 1;
		if(ExperimentCnts > 0)
			pAlignCnts->NumExprInsts += 1;
		UpdateBinInstCnts(pAlignCnts->Bin,RelLoci,ControlCnts,ExperimentCnts);
		return(eBSFSuccess);
		}
	if(pAlignCnts->Bin > (UINT32)(CurBin+1))	// need to insert bin?
		{
		memcpy(&pAlignCnts[1],pAlignCnts,sizeof(tsAlignBinCnts) * (m_NumAlignBins - BinIdx));
		memset(pAlignCnts,0,sizeof(tsAlignBinCnts));
		m_NumAlignBins += 1;
		pAlignCnts->ControlSumCnts = ControlCnts;
		pAlignCnts->ExperimentSumCnts = ExperimentCnts;
		if(ControlCnts > 0)
			pAlignCnts->NumCtrlInsts += 1;
		if(ExperimentCnts > 0)
			pAlignCnts->NumExprInsts += 1;
		pAlignCnts->Bin = CurBin+1;
		UpdateBinInstCnts(pAlignCnts->Bin,RelLoci,ControlCnts,ExperimentCnts);
		return(eBSFSuccess);
		}
	}
// need to append bin
pAlignCnts = &m_pAlignBins[m_NumAlignBins];
memset(pAlignCnts,0,sizeof(tsAlignBinCnts));
m_NumAlignBins+=1;
pAlignCnts->ControlSumCnts = ControlCnts;
pAlignCnts->ExperimentSumCnts = ExperimentCnts;
if(ControlCnts > 0)
	pAlignCnts->NumCtrlInsts = 1;
else
	pAlignCnts->NumCtrlInsts = 0;
if(ExperimentCnts > 0)
	pAlignCnts->NumExprInsts = 1;
else
	pAlignCnts->NumExprInsts = 0;
pAlignCnts->Bin = CurBin + 1;
UpdateBinInstCnts(pAlignCnts->Bin,RelLoci,ControlCnts,ExperimentCnts);
return(eBSFSuccess);
}


teBSFrsltCodes
AddReadHit(bool bIsExperiment,		// true if this is an experimental read
			int Score,				// score associated with this hit	
			char *pszChrom,			// hit to this chrom
			char Strand,			// on this strand
			int StartLoci,			// starts at this loci
			int ReadLen)			// and is of this length
{
size_t memreq;
UINT8 *pTmpAlloc;
UINT32 ChromID;
tsAlignHit *pAlignHit;

// need to allocate more memory?
if(m_NumAlignHits >= m_AllocdAlignHits)
	{
	memreq = (m_AllocdAlignHits + cAlignHitsReAlloc) * sizeof(tsAlignHit);
#ifdef _WIN32
	pTmpAlloc = (UINT8 *) realloc(m_pAlignHits,memreq);
#else
	pTmpAlloc = (UINT8 *)mremap(m_pAlignHits,m_AllocdAlignHits *  sizeof(tsAlignHit),memreq,MREMAP_MAYMOVE);
	if(pTmpAlloc == MAP_FAILED)
		pTmpAlloc = NULL;
#endif
	if(pTmpAlloc == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddReadLoci: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
		Reset();
		return(eBSFerrMem);
		}
	m_pAlignHits = (tsAlignHit *)pTmpAlloc;
	m_AllocdAlignHits += cAlignHitsReAlloc;
	pAlignHit = &m_pAlignHits[m_NumAlignHits];
	memset(pAlignHit,0,sizeof(tsAlignHit) * cAlignHitsReAlloc);
	}

ChromID = ChromToID(pszChrom);
pAlignHit = &m_pAlignHits[m_NumAlignHits++];

pAlignHit->ExprFlag = bIsExperiment ? 1 : 0;
pAlignHit->ChromID = ChromID;
pAlignHit->Loci = StartLoci;
pAlignHit->MatchLen = ReadLen;
pAlignHit->Strand = Strand;
pAlignHit->Score = Score;
return(eBSFSuccess);
}

teBSFrsltCodes
LoadAlignedReadsBED(bool bIsExperiment,		// false if control file, true if experiment
			char *pszInFile,
			char FiltStrand)
{
teBSFrsltCodes Rslt;
int NumProcessed;
CBEDfile *pBEDFile;
int CurFeatureID;
int StartLoci;
int EndLoci;
int Score;
char szChrom[128];
char szFeatName[128];
char Strand;

if((pBEDFile = new CBEDfile)==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CBEDfile");
	return(eBSFerrObj);
	}

if((Rslt=pBEDFile->Open(pszInFile,eBTAnyBed,false,m_LimitAligned)) !=eBSFSuccess)
	{
	while(pBEDFile->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,pBEDFile->GetErrMsg());
	delete pBEDFile;
	return(eBSFerrOpnFile);
	}

CurFeatureID = 0;
NumProcessed = 0;
while(Rslt == eBSFSuccess && (CurFeatureID = pBEDFile->GetNextFeatureID(CurFeatureID)) > 0)
	{
	if(m_LimitAligned > 0 && (UINT32)NumProcessed > m_LimitAligned)
		break;

	if(!(NumProcessed % 100000))
		{
		if(!NumProcessed)
			printf("\n     processing aligned read %9.9d",NumProcessed);
		else
			printf("\b\b\b\b\b\b\b\b%9.9d",NumProcessed);
		}
	NumProcessed += 1;

	pBEDFile->GetFeature(CurFeatureID,// feature instance identifier
				szFeatName,				// where to return feature name
				szChrom,				// where to return chromosome name
				&StartLoci,				// where to return feature start on chromosome (0..n) 
				&EndLoci,				// where to return feature end on chromosome
 				&Score,					// where to return score
 				&Strand);				// where to return strand

	
	if(FiltStrand != '*' && Strand != FiltStrand)
		continue;

	if((Rslt = AddReadHit(bIsExperiment, // true if this is an experimental read
			Score,					// score associated with this hit	
			szChrom,				// hit to this chrom
			Strand,					// on this strand
			StartLoci,				// starts at this loci
			1 + EndLoci - StartLoci))	// and is of this length
			!= eBSFSuccess)
		{
		delete pBEDFile;
		return(Rslt);
		}
	}
delete pBEDFile;
return(eBSFSuccess);
}


teBSFrsltCodes
LoadAlignedReadsCSV(bool bIsExperiment,		// false if control file, true if experiment
			char *pszInFile,		// load reads from this file
		  char FiltStrand)			    // process for this strand '+' or '-' or for both '*'
{
teBSFrsltCodes Rslt;
int NumProcessed;
int ReadID;
int MatchLen;
char *pszTargSpecies;
char *pszChromName;
int Loci;
char *pszStrand;
int NumExclReads;

int NumFields;


CCSVFile *pCSVAligns = NULL;


// load into memory
if((pCSVAligns = new CCSVFile) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CCSVfile");
	return(eBSFerrObj);
	}
pCSVAligns->SetMaxFields(14);	// expecting at least 8, upto 14, fields in reads alignment CSV file
if((pCSVAligns->Open(pszInFile))<0)
	{
	while(pCSVAligns->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,pCSVAligns->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open file: %s",pszInFile);
	delete pCSVAligns;
	return(eBSFerrOpnFile);
	}

NumExclReads = 0;
NumProcessed = 0;
while((Rslt=(teBSFrsltCodes)pCSVAligns->NextLine()) > 0)	// onto next line containing fields
	{
	if(m_LimitAligned > 0 && (UINT32)NumProcessed > m_LimitAligned)
		{
		Rslt = eBSFSuccess;
		break;
		}
	if(!(NumProcessed % 100000))
		{
		if(!NumProcessed)
			printf("\n     processing aligned read %9.9d",NumProcessed);
		else
			printf("\b\b\b\b\b\b\b\b\b%9.9d",NumProcessed);
		}

	NumFields = pCSVAligns->GetCurFields();
	if(NumFields < 8)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"file: %s contains % fields, expected at least 8",pszInFile,NumFields);
		delete pCSVAligns;
		return(eBSFerrParams);
		}

	if(!NumProcessed && pCSVAligns->IsLikelyHeaderLine())
		continue;
	NumProcessed += 1;
	pCSVAligns->GetInt(1,&ReadID);
	pCSVAligns->GetText(3,&pszTargSpecies);
	pCSVAligns->GetText(4,&pszChromName);
	pCSVAligns->GetInt(5,&Loci);
	pCSVAligns->GetInt(7,&MatchLen);
	pCSVAligns->GetText(8,&pszStrand);
	if(FiltStrand != '*' && FiltStrand != *pszStrand)
		continue;

	if((Rslt = AddReadHit(bIsExperiment,// true if this is an experimental read
			1,							// score associated with this hit	
			pszChromName,				// hit to this chrom
			*pszStrand,					// on this strand
			Loci,						// starts at this loci
			MatchLen))					// and is of this length
			!= eBSFSuccess)
		{
		delete pCSVAligns;
		return(Rslt);
		}
	}
delete pCSVAligns;
return(Rslt);
}

char *
IDtoChrom(UINT32 ChromID)	// returns ptr to chrom for ChromID
{
if(m_pChroms == NULL || ChromID == 0 || ChromID > (UINT32)m_CurNumChroms)
	return(NULL);

return(m_pChroms[ChromID-1].szChromName);
}

UINT32
ChromToID(char *pszChrom)	// get unique chromosome identifier
{
tsRefIDChrom *pNewChrom;
UINT16 aHash = CUtility::GenHash16(pszChrom);

if(m_pChroms == NULL)		// NULL if first time...
	{
	m_pChroms = new tsRefIDChrom [cChromsInitalAllocNum];
	if(m_pChroms == NULL)
		return(0);
	m_NumChromsAllocd = cChromsInitalAllocNum;
	m_CurNumChroms = 0;
	m_MRAChromID = 0;
	}


if(m_CurNumChroms != 0)
	{
	// high probability that chromosome will be one which was last accessed
	if(m_MRAChromID > 0)
		{
		pNewChrom = &m_pChroms[m_MRAChromID-1];
		if(aHash == pNewChrom->Hash && !stricmp(pszChrom,pNewChrom->szChromName))
			return(pNewChrom->ChromID);
		}
	// not most recently accessed, need to do a linear search
	pNewChrom = m_pChroms;
	for(m_MRAChromID = 1; m_MRAChromID <= m_CurNumChroms; m_MRAChromID++,pNewChrom++)
		if(aHash == pNewChrom->Hash && !stricmp(pszChrom,pNewChrom->szChromName))
			return(pNewChrom->ChromID);
	}

if(m_CurNumChroms == m_NumChromsAllocd)
	{
	pNewChrom = new tsRefIDChrom [m_NumChromsAllocd + cChromsGrowAllocNum];
	if(pNewChrom == NULL)
		return(0);
	memcpy(pNewChrom,m_pChroms,sizeof(tsRefIDChrom) * m_CurNumChroms);
	delete m_pChroms;
	m_pChroms = pNewChrom;
	m_NumChromsAllocd += cChromsGrowAllocNum;
	}

// new chromosome entry
pNewChrom = &m_pChroms[m_CurNumChroms++];
pNewChrom->Hash = aHash;
strcpy(pNewChrom->szChromName,pszChrom);
pNewChrom->ChromID = m_CurNumChroms;
m_MRAChromID = m_CurNumChroms;
return((UINT32)m_CurNumChroms);
}

int
LoadAlignedReads(bool bExpr,	// false if loading control, true if loading experiment
			char Strand,		// process for this strand '+' or '-' or for both '*'
			int FType,				// input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM
			char *pszInAlignFile)	// load control aligned reads from this file)
{
int Rslt;
etClassifyFileType FileType;
if(FType == 0)
	FileType = CUtility::ClassifyFileType(pszInAlignFile);
else
	FileType = (etClassifyFileType)(FType - 1);

switch(FileType) {
	case eCFTopenerr:		// unable to open file for reading
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open file: '%s'",pszInAlignFile);
		return(eBSFerrOpnFile);

	case eCFTlenerr:		// file length is insufficent to classify type
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to classify file type (insuffient data points): '%s'",pszInAlignFile);
		return(eBSFerrFileAccess);

	case eCFTunknown:		// unable to reliably classify
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to reliably classify file type: '%s'",pszInAlignFile);
		return(eBSFerrFileType);
 
	case eCFTCSV:			// file has been classified as being CSV
		Rslt = LoadAlignedReadsCSV(bExpr,pszInAlignFile,Strand);
		break;

	case eCFTBED:			// file has been classified as being BED
		Rslt = LoadAlignedReadsBED(bExpr,pszInAlignFile,Strand);
		break;

	case eCFTSAM:			// file has been classified as being SAM
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Currently unable to process SAM files: '%s'",pszInAlignFile);
		return(eBSFerrFileType);
	}
return(Rslt);
}

int
LoadAlignedReadFiles(char Strand,		// process for this strand '+' or '-' or for both '*'
			int FType,					// input element file format: 0 - auto, 1 - CSV, 2 - BED, 3 - SAM
			int NumInputControlSpecs,	// number of input file specs 
			char **pszInControlFiles,	// input control aligned reads files
			int NumInputExperimentSpecs,// number of input file specs 
			char **pszInExperimentFiles)	// input experiment aligned reads files
{
int Rslt;
int Idx;
char *pszInfile;
int NumInputFilesProcessed;
size_t memreq;


if(m_pAlignHits == NULL)
	{
	memreq = cAlignHitsInitalAlloc * sizeof(tsAlignHit);
#ifdef _WIN32
	m_pAlignHits = (tsAlignHit *) malloc((size_t)memreq);	
	if(m_pAlignHits == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddEntry: Memory allocation of %lld bytes failed",(INT64)memreq);
		Reset();
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pAlignHits = (tsAlignHit *)mmap(NULL,(size_t)memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pAlignHits == MAP_FAILED)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadAlignedReadFiles: Memory allocation of %lld bytes through mmap()  failed",(INT64)memreq,strerror(errno));
		m_pAlignHits = NULL;
		Reset();
		return(eBSFerrMem);
		}
#endif
	m_AllocdAlignHits = cAlignHitsInitalAlloc;
	m_NumAlignHits = 0;
	memset(m_pAlignHits,0,memreq);
	}

CSimpleGlob glob(SG_GLOB_FULLSORT);
NumInputFilesProcessed = 0;
for(Idx = 0; Idx < NumInputControlSpecs; Idx++)
	{
	glob.Init();
	if(glob.Add(pszInControlFiles[Idx]) < SG_SUCCESS)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to glob '%s",pszInControlFiles[Idx]);
		Reset();
		return(eBSFerrOpnFile);	// treat as though unable to open file
		}
	if(glob.FileCount() <= 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to locate any input control file matching '%s",pszInControlFiles[Idx]);
		continue;
		}

	Rslt = eBSFSuccess;
	for (int FileID = 0; Rslt >= eBSFSuccess &&  FileID < glob.FileCount(); ++FileID)
		{
		pszInfile = glob.File(FileID);
		NumInputFilesProcessed += 1;
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: Loading control read alignments from file: %s",pszInfile);
		Rslt = LoadAlignedReads(false,Strand,FType,pszInfile);
		if(Rslt < 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadAlignedReadFiles: Failed loading control read alignments from file: %s",pszInfile);
			Reset();
			return(Rslt);
			}
		printf("\b\b\b\b\b\b\b\b\b%9.9d",m_NumAlignHits);
		}
	}

if(NumInputFilesProcessed == 0)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadAlignedReadFiles: Failed to load any control read alignments from any file");
	Reset();
	return(eBSFerrOpnFile);
	}

m_ControlAlignedHits = m_NumAlignHits;
gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: Accepted %d control aligned reads on strand '%c'",m_ControlAlignedHits,Strand);

NumInputFilesProcessed = 0;
for(Idx = 0; Idx < NumInputExperimentSpecs; Idx++)
	{
	glob.Init();
	if(glob.Add(pszInExperimentFiles[Idx]) < SG_SUCCESS)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to glob '%s",pszInExperimentFiles[Idx]);
		Reset();
		return(eBSFerrOpnFile);	// treat as though unable to open file
		}
	if(glob.FileCount() <= 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to locate any input experiment file matching '%s",pszInControlFiles[Idx]);
		continue;
		}

	Rslt = eBSFSuccess;
	for (int FileID = 0; Rslt >= eBSFSuccess &&  FileID < glob.FileCount(); ++FileID)
		{
		pszInfile = glob.File(FileID);
		NumInputFilesProcessed += 1;
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: Loading experiment read alignments from file: %s",pszInfile);
		Rslt = LoadAlignedReads(true,Strand,FType,pszInfile);
		if(Rslt < 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadAlignedReadFiles: Failed loading experiment read alignments from file: %s",pszInfile);
			Reset();
			return(Rslt);
			}
		m_ExperimentAlignedHits = m_NumAlignHits - m_ControlAlignedHits;
		printf("\b\b\b\b\b\b\b\b\b%9.9d",m_ExperimentAlignedHits);
		}
	}

if(NumInputFilesProcessed == 0)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadAlignedReadFiles: Failed to load any experiment read alignments from any file");
	Reset();
	return(eBSFerrOpnFile);
	}

gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: accepted %d experiment aligned reads on strand '%c'",m_ExperimentAlignedHits,Strand);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: accepted total of %d control and experiment aligned reads on strand '%c'",m_NumAlignHits,Strand);

	// finally, create sorted index by chrom, loci, strand, control over the loaded aligned reads
gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: sorting %d aligned reads...",m_NumAlignHits);
qsort(m_pAlignHits,m_NumAlignHits,sizeof(tsAlignHit),SortAlignments);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedReadFiles: sorting %d aligned reads completed",m_NumAlignHits);

return(Rslt);
}


int
LocateStartALignment(char Strand,UINT32 ChromID,UINT32 StartLoci,UINT32 EndLoci)
{
if(m_pAlignHits == NULL|| m_NumAlignHits == 0)
	return(0);

tsAlignHit *pEl2;

int CmpRslt;

UINT32 Mark;
UINT32 TargPsn;
UINT32 Lo,Hi;

Lo = 0;
Hi = m_NumAlignHits - 1;
do {
	TargPsn = (Lo + Hi) / 2;
	pEl2 = &m_pAlignHits[TargPsn];
	CmpRslt = 0;
	if(ChromID < pEl2->ChromID)
		CmpRslt = -1;
	else
		if(ChromID > pEl2->ChromID)
			CmpRslt = 1;

	if(!CmpRslt && EndLoci < pEl2->Loci)
		CmpRslt = -1;
	else
		if(!CmpRslt && StartLoci > pEl2->Loci)
			CmpRslt = 1;

	if(!CmpRslt && Strand != '*')
		{
		if(Strand != pEl2->Strand)
			CmpRslt = Strand == '+' ? -1 : 1;
		}

	if(!CmpRslt)	// if a match then may not be the lowest indexed match
		{
		if(TargPsn == 0 || Lo == TargPsn) // check if already lowest
			{
			if(pEl2->Loci > EndLoci)
				return(0);
			return(TargPsn + 1);
			}
		// iterate until lowest located
		while(1) {
			if(CmpRslt == 0)
				{
				Mark = TargPsn;
				if(Mark == 0)
					{
					if(pEl2->Loci > (UINT32)EndLoci)
						return(0);
					return(Mark+1);
					}
				Hi = TargPsn - 1;
				}	
			TargPsn = ((UINT64)Lo + Hi) / 2L;
			pEl2 = &m_pAlignHits[TargPsn];

			CmpRslt = 0;
			if(ChromID < pEl2->ChromID)
				CmpRslt = -1;
			else
				if(ChromID > pEl2->ChromID)
					CmpRslt = 1;
			if(!CmpRslt && EndLoci < pEl2->Loci)
				CmpRslt = -1;
			else
				if(!CmpRslt && StartLoci > pEl2->Loci)
					CmpRslt = 1;
			if(!CmpRslt && Strand != '*')
				{
				if(Strand != pEl2->Strand)
					CmpRslt = Strand == '+' ? -1 : 1;
				}

			if(CmpRslt == 0)				// 0 if still matching
				continue;
			Lo = TargPsn + 1;
			if(Lo == Mark)
				{
				if(pEl2->Loci > EndLoci)
					return(0);
				return(Mark+1);
				}
			}
		}

	if(CmpRslt < 0)
		{
		if(TargPsn == 0)
			break;
		Hi = TargPsn - 1;
		}
	else
		Lo = TargPsn+1;
	}
while(Hi >= Lo);

return(0);	// unable to locate any alignment instances
}


typedef struct TAG_sAlignDiffCnts {
	UINT32 ControlCnts;
	UINT32 ExperimentCnts;
} tsAlignDiffCnts;

teBSFrsltCodes
GenRankedDiffList(char Strand,				// alignments must be to this strand
				  char *pszChrom,			// alignments are on this chrom
				  UINT32 StartLoci,			// must start on or after this loci
				  UINT32 EndLoci)			// must start on or before this loci
{
teBSFrsltCodes Rslt;
switch(m_PMode) {
	case ePMcoverage:
		Rslt = GenRankedDiffListAlignDensity(Strand,pszChrom,StartLoci,EndLoci);
		break;
	case ePMstarts:
		Rslt = GenRankedDiffListAlignStarts(Strand,pszChrom,StartLoci,EndLoci);
		break;
	}
return(Rslt);
}

teBSFrsltCodes
GenRankedDiffListAlignDensity(char Strand,	// alignments must be to this strand
				  char *pszChrom,			// alignments are on this chrom
				  UINT32 StartLoci,			// must start on or after this loci
				  UINT32 EndLoci)			// must start on or before this loci
{
UINT32 ChromID;
UINT32 AlignIdx;

tsAlignDiffCnts AlignDiffCnts[cMaxReadLen+1];
tsAlignDiffCnts *pDiffCnts;
int CurAlignDiffIdx;

UINT32 ControlCnts;
UINT32 ExperimentCnts;

int CntsIdx;
int Idy;
UINT32 CurLociy;
int MaxAlignLen;

int CurLoci;
int CurBin;
int PrvBin;
tsAlignHit *pAlignHit;

m_CurFeatLen += 1 + EndLoci - StartLoci;

// position to alignment at lowest loci >= StartLoci
if((ChromID = ChromToID(pszChrom)) == 0)
	return(eBSFSuccess);

if((AlignIdx = (UINT32)LocateStartALignment(Strand,ChromID,StartLoci,EndLoci))==0)
	return(eBSFSuccess);
pAlignHit = &m_pAlignHits[AlignIdx -1];
ControlCnts = 0;
ExperimentCnts = 0;
CurLoci = -1;
CurBin = 0;
PrvBin = 0;
CurAlignDiffIdx = 0;
MaxAlignLen = 0;
memset(AlignDiffCnts,0,sizeof(AlignDiffCnts));
for(; AlignIdx < m_NumAlignHits; AlignIdx++,pAlignHit++)
	{
	if(pAlignHit->ChromID != ChromID ||						// only interested in alignment if still on ChromID and starting <= EndLoci
		pAlignHit->Loci > EndLoci)
		break;

	if(Strand != '*' && Strand != pAlignHit->Strand)		// only interested in alignment if on requested strand
		continue;

	// accepted this aligned read
	if(CurLoci != -1 && pAlignHit->Loci != CurLoci)
		{
		// reads starting from a new loci
		CntsIdx = CurAlignDiffIdx;
		pDiffCnts = &AlignDiffCnts[CntsIdx];
		for(Idy = 0; Idy < MaxAlignLen &&  CurLoci < (int)pAlignHit->Loci; Idy++,CntsIdx++,pDiffCnts++)
			{
			if(CntsIdx >= cMaxReadLen)
				{
				CntsIdx = 0;
				pDiffCnts = AlignDiffCnts; 
				}
			if(pDiffCnts->ControlCnts || pDiffCnts->ExperimentCnts)
				AddAlignDiffCnts(CurLoci - StartLoci,pDiffCnts->ControlCnts,pDiffCnts->ExperimentCnts);
			pDiffCnts->ControlCnts = 0;
			pDiffCnts->ExperimentCnts = 0;
			CurAlignDiffIdx += 1;
			if(CurAlignDiffIdx >= cMaxReadLen)
				CurAlignDiffIdx = 0;
			MaxAlignLen -= 1;
			CurLoci += 1;
			}
		}
	
	CurLoci = pAlignHit->Loci;

	// accumulate counts for control and experiment
	// option needs to be for accumulation over full length of alignments up to EndLoci.....
	CntsIdx = CurAlignDiffIdx;
	pDiffCnts = &AlignDiffCnts[CurAlignDiffIdx];
	CurLociy = CurLoci;
	for(Idy = 0; Idy < pAlignHit->MatchLen && CurLociy < EndLoci; Idy++,CntsIdx++,CurLociy++,pDiffCnts++)
		{
		if(CntsIdx >= cMaxReadLen)
			{
			CntsIdx = 0;
			pDiffCnts = AlignDiffCnts;
			}
		if(pAlignHit->ExprFlag == 0)
			pDiffCnts->ControlCnts++;
		else
			pDiffCnts->ExperimentCnts++;
		
		}
	if(Idy > MaxAlignLen)
		MaxAlignLen = Idy;
	}

if(MaxAlignLen > 0)
	{
	CntsIdx = CurAlignDiffIdx;
	pDiffCnts = &AlignDiffCnts[CntsIdx];
	for(Idy = 0; Idy < MaxAlignLen &&  CurLoci < (INT32)EndLoci; Idy++,CntsIdx++,CurLoci++,pDiffCnts++)
		{
		if(!(CntsIdx % cMaxReadLen))
			{
			CntsIdx = 0;
			pDiffCnts = AlignDiffCnts; 
			}
		if(pDiffCnts->ControlCnts || pDiffCnts->ExperimentCnts)
			AddAlignDiffCnts(CurLoci - StartLoci,pDiffCnts->ControlCnts,pDiffCnts->ExperimentCnts);
		}
	}

return(eBSFSuccess);
}

teBSFrsltCodes
GenRankedDiffListAlignStarts(char Strand,	// alignments must be to this strand
				  char *pszChrom,			// alignments are on this chrom
				  UINT32 StartLoci,			// must start on or after this loci
				  UINT32 EndLoci)			// must start on or before this loci
{
UINT32 ChromID;
UINT32 AlignIdx;

int CurAlignDiffIdx;

UINT32 ControlCnts;
UINT32 ExperimentCnts;

int CurLoci;
int CurBin;
int PrvBin;
tsAlignHit *pAlignHit;

m_CurFeatLen += 1 + EndLoci - StartLoci;

// position to alignment at lowest loci >= StartLoci
if((ChromID = ChromToID(pszChrom)) == 0)
	return(eBSFSuccess);

if((AlignIdx = (UINT32)LocateStartALignment(Strand,ChromID,StartLoci,EndLoci))==0)
	return(eBSFSuccess);
pAlignHit = &m_pAlignHits[AlignIdx -1];
ControlCnts = 0;
ExperimentCnts = 0;
CurLoci = -1;
CurBin = 0;
PrvBin = 0;
CurAlignDiffIdx = 0;
for(; AlignIdx < m_NumAlignHits; AlignIdx++,pAlignHit++)
	{
	if(pAlignHit->ChromID != ChromID ||						// only interested in alignment if still on ChromID and starting <= EndLoci
		pAlignHit->Loci > EndLoci)
		break;

	if(Strand != '*' && Strand != pAlignHit->Strand)		// only interested in alignment if on requested strand
		continue;

	// accepted this aligned read
	if(CurLoci != -1 && pAlignHit->Loci != CurLoci)
		{
		// onto a different loci
		AddAlignDiffCnts(CurLoci - StartLoci,ControlCnts,ExperimentCnts);
		ControlCnts = 0;
		ExperimentCnts = 0;
		}
	
	// accumulate counts for control and experiment
	if(pAlignHit->ExprFlag == 0)
		ControlCnts++;
	else
		ExperimentCnts++;
	CurLoci = pAlignHit->Loci;
	}

if(ControlCnts > 0 || ExperimentCnts > 0)
	{
	// at least one control or experiment alignment
	AddAlignDiffCnts(CurLoci - StartLoci,ControlCnts,ExperimentCnts);
	}
return(eBSFSuccess);
}


//
// AnalyticsTest
// applies users choice of either Mann Whitney U-Test or Wilcoxon scaled rank
//
// notes to self
// if U-Test then the ranking is on the absolute cnts so only actually need the scaled counts and count sources
// if Wilcoxon scaled rank then ranking is on the differences
//
int
AnalyticsTest(char *pszFeatName)
{
int Rslt;
switch(m_ATest) {
	case eATMannWhitney:
		Rslt = MannWhitney(pszFeatName);
		break;
	case eATWilcoxon:
		Rslt = Wilcoxon(pszFeatName);
		break;
	}
if(Rslt >= eBSFSuccess)
	Rslt = ReportBinCounts(false,pszFeatName);	// Pearsons would have been already generated within the MannWhitney or Wilcoxon processing
return(Rslt);
}

const double cConfInterval95 = 1.959963984540;
const double cConfInterval99 = 2.575829303549;

// Convert Fisher z' to Pearson r
double
z2r(double z)
{
if(z >= 17.6163615864504)
	return(1.0);
if(z <= 17.6163615864504)
	return(-1.0);
double e = exp(2.0 * z);
return((e-1)*(e+1));
}

// Convert Pearson r to Fisher z'
// Note that Pearson is checked for the possiblity of an underflow 
double
r2z(double r)
{
if(r > 0.999999999999999)
	return(17.6163615864504);
if(r < -0.999999999999999)
	return(-17.6163615864504);
return(log((1.0+r)/(1.0-r))/2.0);
}

double								// returns *pUpper - *pLower 
ConfInterval95(int N,				// number of bins containing at least one count
			   double Pearson,		// Pearsons r
			   double *pUpper,		// returned upper for a confidence interval of 95
			   double *pLower)		// returned upper for a confidence interval of 95
{
double z;
double uz;
double lz;
double StdErr;

if(N < 4)
	N = 4;

StdErr = 1.0/sqrt((double(N-3)));

z = r2z(Pearson);
uz = z + (cConfInterval95 * StdErr);
lz = z - (cConfInterval95 * StdErr);

uz = exp(2*uz);
if(uz == -1.0)
	uz += 0.000000001; 

lz = exp(2*lz);
if(lz == -1.0)
	lz += 0.000000001; 

*pUpper = (uz-1.0)/(uz+1.0);
*pLower = (lz-1.0)/(lz+1.0);

return(*pUpper - *pLower);
}

double								// returns *pUpper - *pLower 
ConfInterval99(int N,				// number of bins containing at least one count
			   double Pearson,		// Pearsons r
			   double *pUpper,		// returned upper for a confidence interval of 95
			   double *pLower)		// returned upper for a confidence interval of 95
{
double z;
double uz;
double lz;
double StdErr;

if(N < 4)
	N = 4;

StdErr = 1.0/sqrt((double(N-3)));

z = r2z(Pearson);
uz = z + (cConfInterval99 * StdErr);
lz = z - (cConfInterval99 * StdErr);

uz = exp(2*uz);
if(uz == -1.0)
	uz += 0.000000001; 

lz = exp(2*lz);
if(lz == -1.0)
	lz += 0.000000001; 

*pUpper = (uz-1.0)/(uz+1.0);
*pLower = (lz-1.0)/(lz+1.0);

return(*pUpper - *pLower);
}



// Pearson sample correlation coefficient
// Defined as the covariance of the two variables divided by the product of their standard deviations
// A count of 1 is added to both control and experiment so as to provide for Laplaces smoothing and prevent divide by zero errors
double									// returned Pearson
Pearsons(int NumAlignCnts,				// number of bins containing at least one alignment count for either control or experiment
		tsAlignBinCnts *pAlignCnts)		// bins containing alignment counts
{
tsAlignBinCnts *pACnts;
int Idx;
int NumLociCnts;
double MeanC;
double MeanE;
double TmpC;
double TmpE;
double SumNum;
double SumDenC;
double SumDenE;
double Correl;

MeanC = 0.0;
MeanE = 0.0;
NumLociCnts = 0;
pACnts = pAlignCnts;

// calc the means
for(Idx = 0; Idx < NumAlignCnts; Idx++, pACnts++)		
	{
	if(pACnts->ControlSumCnts < 1 && pACnts->ExperimentSumCnts < 1) // shouldn't occur but skip bins for which there are no control or experimental counts
		continue;
	NumLociCnts += 1;
	MeanC += pACnts->ControlSumCnts+1;								// adding a psuedocount of 1 is Laplace's smoothing
	MeanE += pACnts->ExperimentSumCnts+1;							// which also conveniently ensures can never have divide by zero errors!
	}
if(NumLociCnts == 0)
	return(0.0);

MeanC /= NumLociCnts;												// can now determine the means
MeanE /= NumLociCnts;

if(MeanC < 0.9 || MeanE < 0.9)										// should never have means of less than 1.0 because of Laplace's add 1
	return(0.0);

SumNum = 0.0;
SumDenC = 0.0;
SumDenE = 0.0;
pACnts = pAlignCnts;
for(Idx = 0; Idx < NumAlignCnts; Idx++, pACnts++)
	{
	if(pACnts->ControlSumCnts < 1 && pACnts->ExperimentSumCnts < 1) // shouldn't occur but skip bins for which there are no control or experimental counts
		continue;
	TmpC = (pACnts->ControlSumCnts + 1) - MeanC;					// adding a psuedocount of 1 is Laplace's smoothing
	TmpE = (pACnts->ExperimentSumCnts + 1) - MeanE;
	SumNum += (TmpC * TmpE);
	SumDenC += (TmpC * TmpC);
	SumDenE += (TmpE * TmpE);
	}

if(SumDenC < 0.00001)			// set a floor so as to prevent the chance of a subsequent divide by zero error
	SumDenC = 0.00001;
if(SumDenE < 0.00001)
	SumDenE = 0.00001;
Correl = SumNum/sqrt(SumDenC*SumDenE);
return(Correl);
}

// Calculate a PValue for the given Pearson through a counts permutation test
// Permutes counts by randomly adding/removing counts in the experimental bins 
double
PearsonsPValue(double Pearson,			// 
		int MaxPerms,					// maximum number of permutions
		int NumAlignCntBins,			// number of bins containing at least one alignment count for either control or experiment
		tsAlignBinCnts *pAlignCnts,		// bins containing alignment counts
		double *pLow95,					// returned low 95 percentile 
		double *pUp95,					// returned upper 95 percentile 
		double *pMedian)				// returned median
{
int PermIter;
int SrcIdx;
int MaxNumPerms;
int Supportive;
double *pPearson;
tsAlignBinCnts *pOrgCnts;
tsAlignBinCnts *pSrcCnts;
tsAlignLociInstCnts *pAlignLoci;
int AlignLociIdx;
int SrcCnts;
int NoiseCnts;
UINT32 ControlSumCnts;
UINT32 ExperimentSumCnts;
double CurPearson;

*pLow95 = 0.0;
*pUp95 = 0.0;
*pMedian = 0.0;
if(NumAlignCntBins < 1)	// if less than 1 bin then can't really determine a PValue..
	return(0.0);

if(m_pPermAlignBinCnts == NULL || NumAlignCntBins > (int)m_AllocNumAlignBins)
	{
	if(m_pPermAlignBinCnts != NULL)
		delete m_pPermAlignBinCnts;
	m_AllocNumAlignBins = (size_t)max(NumAlignCntBins + 100,cMaxNumAlignBins);
	m_pPermAlignBinCnts = new tsAlignBinCnts[m_AllocNumAlignBins];
	}

if(m_pPearsons == NULL || MaxPerms > (int)m_AllocNumPearsons)
	{
	if(m_pPearsons != NULL)
		delete m_pPearsons;
	m_AllocNumPearsons = (size_t)max(MaxPerms + 100,cMaxNumPearsons);
	m_pPearsons = new double[m_AllocNumPearsons];
	}

memcpy(m_pPermAlignBinCnts,pAlignCnts,sizeof(tsAlignBinCnts) * NumAlignCntBins);
MaxNumPerms = NumAlignCntBins * 200;
if(MaxNumPerms > MaxPerms)
	MaxNumPerms = MaxPerms;

Supportive = 0;
pPearson = m_pPearsons;
for(PermIter = 0; PermIter < MaxNumPerms; PermIter++,pPearson++)
	{
	pOrgCnts = pAlignCnts;
	pSrcCnts = m_pPermAlignBinCnts; 
	for(SrcIdx = 0; SrcIdx < NumAlignCntBins; SrcIdx++,pSrcCnts++,pOrgCnts++)
		{
		// iterate over all loci starts in the current bin, add noise and sum for both experiment and control
		pAlignLoci = m_pBinInstsCnts;
		ControlSumCnts = 0;
		ExperimentSumCnts = 0;
		for(AlignLociIdx = 0; AlignLociIdx < (int)m_NumBinInstCnts;AlignLociIdx++,pAlignLoci++)
			{
			if(pSrcCnts->Bin != pAlignLoci->Bin)
				continue;
				// add random cnts to the control counts
			SrcCnts = (int)pAlignLoci->NumCtrlCnts;
			NoiseCnts = m_SimpleRNG.GetPoisson(SrcCnts);
			ControlSumCnts += NoiseCnts;

			// add random cnts to the experiment counts
			SrcCnts = (int)pAlignLoci->NumExprCnts;
			NoiseCnts = m_SimpleRNG.GetPoisson(SrcCnts);
			ExperimentSumCnts += NoiseCnts;
			}

		pSrcCnts->ControlSumCnts = ControlSumCnts;
		pSrcCnts->ExperimentSumCnts = ExperimentSumCnts;
		}
	CurPearson = Pearsons(NumAlignCntBins,m_pPermAlignBinCnts);
	*pPearson = CurPearson;
	if(CurPearson > Pearson)
		Supportive += 1;
	}
qsort(m_pPearsons,MaxNumPerms,sizeof(double),SortPearsons);
int LowerIdx;
int UpperIdx;

LowerIdx = (MaxNumPerms-1)/2;
if(MaxNumPerms & 0x01)
	*pMedian = m_pPearsons[LowerIdx];
else
	*pMedian = (m_pPearsons[LowerIdx] + m_pPearsons[LowerIdx+1])/2.0;
LowerIdx = (MaxNumPerms * 5) / 200;
UpperIdx = MaxNumPerms - LowerIdx;
*pLow95 = m_pPearsons[LowerIdx];
*pUp95 = m_pPearsons[UpperIdx];
return(1.0 - ((double)Supportive/MaxNumPerms));
}



int 
ReportBinCounts(bool bGenPearsons,		// true if Pearsons to be generated, false if m_Pearsons already initialised with Pearsons
				char *pszFeatName)		// reporting is for this feature
{
int Idx;
UINT32 CurBin;
UINT32 TotBins;
UINT32 TotCtrlBins;
UINT32 TotExprBins;
UINT32 TotCtrlExprBins;

int TotCtrlCnts;
int TotExprCnts;
char szBuff[8196];
int BuffIdx;
tsAlignBinCnts *pAlignCnts;

if(m_hBinCountsFile == -1)
	return(eBSFSuccess);


if(m_BinLen < 0)
	TotBins = max(1,m_CurRegionLen / abs(m_BinLen));
else
	TotBins = m_BinLen;

if(m_BinLen > 0 && m_bWrtBinHdr)
	{
	BuffIdx = sprintf(szBuff,"\"Feat\",\"FeatLen\",\"TotCtrlCnts\",\"TotExprCnts\",\"TotCtrlExprCnts\",\"FoldChange\",\"Which\",\"Pearson\",\"PearsonMedian\",\"PearsonPValue\",\"PearsonLow95\",\"PearsonUp95\",\"TotBins\",\"CtrlAndExprBins\",\"CtrlOnlyBins\",\"ExprOnlyBins\"");
	for(CurBin = 1; CurBin <= TotBins; CurBin++)
		{
		BuffIdx += sprintf(&szBuff[BuffIdx],",\"Bin%d\"",CurBin);
		if((BuffIdx + 1000) > sizeof(szBuff))
			{
			CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
			BuffIdx = 0;
			}
		}
	BuffIdx += sprintf(&szBuff[BuffIdx],"\n");
	CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
	BuffIdx = 0;
	m_bWrtBinHdr = false;
	}

if(m_NumAlignBins < 1)
	{
	BuffIdx = sprintf(szBuff,"\"%s\",%d,0,0,0,0.0,\"Control\",0.0,0.0,0.0,0.0,0.0,%d,0,0,0",pszFeatName,m_CurFeatLen,TotBins);
	CurBin = 1;
	while(CurBin <= TotBins)
		{
		BuffIdx += sprintf(&szBuff[BuffIdx],",0");
		if((BuffIdx + 1000) > sizeof(szBuff))
			{
			CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
			BuffIdx = 0;
			}
		CurBin += 1;
		}
	BuffIdx += sprintf(&szBuff[BuffIdx],"\n\"%s\",%d,0,0,0,0.0,\"Experiment\",0.0,0.0,0.0,0.0,0.0,%d,0,0,0",pszFeatName,m_CurFeatLen,TotBins);
	CurBin = 1;
	while(CurBin <= TotBins)
		{
		BuffIdx += sprintf(&szBuff[BuffIdx],",0");
		if((BuffIdx + 1000) > sizeof(szBuff))
			{
			CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
			BuffIdx = 0;
			}
		CurBin += 1;
		}
	BuffIdx += sprintf(&szBuff[BuffIdx],"\n");
	CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
	return(eBSFSuccess);
	}

if(bGenPearsons)
	{
	m_Pearson = Pearsons(m_NumAlignBins,m_pAlignBins);
	m_PearsonPValue = PearsonsPValue(m_Pearson,10000,m_NumAlignBins,m_pAlignBins,&m_Low95,&m_Up95,&m_PearsonMedian);
	if(m_CurFeatCtrlCntsTotal == 0)
		m_CurFoldChange = 1.1 * m_CurFeatExprCntsTotal;
	else
		{
		if(m_CurFeatExprCntsTotal == 0)
			m_CurFoldChange = -1.1 * m_CurFeatCtrlCntsTotal;
		else
			{
			m_CurFoldChange = (double)m_CurFeatExprCntsTotal/(double)m_CurFeatCtrlCntsTotal;
			if(m_CurFoldChange < 1.0)
				m_CurFoldChange = -1.0/m_CurFoldChange;
			}
		}
	}

pAlignCnts = m_pAlignBins;
TotCtrlCnts = 0;
TotExprCnts = 0;
TotCtrlBins = 0;
TotExprBins = 0;
TotCtrlExprBins = 0;
for(Idx = 0; Idx < (int)m_NumAlignBins; Idx++, pAlignCnts++)
	{
	if(pAlignCnts->ControlSumCnts > 0)
		{
		TotCtrlCnts += pAlignCnts->ControlSumCnts;
		if(pAlignCnts->ExperimentSumCnts == 0)
			TotCtrlBins += 1;
		}
	if(pAlignCnts->ExperimentSumCnts > 0)
		{
		TotExprCnts += pAlignCnts->ExperimentSumCnts;
		if(pAlignCnts->ControlSumCnts == 0)
			TotExprBins += 1;
		}
	if(pAlignCnts->ControlSumCnts > 0 && pAlignCnts->ExperimentSumCnts > 0)
		TotCtrlExprBins += 1;
	}

BuffIdx = sprintf(szBuff,"\"%s\",%d,%d,%d,%d,%f,\"Control\",%f,%f,%f,%f,%f,%d,%d,%d,%d",pszFeatName,m_CurFeatLen,m_CurFeatCtrlCntsTotal,m_CurFeatExprCntsTotal,m_CurFeatCtrlCntsTotal+m_CurFeatExprCntsTotal,m_CurFoldChange,m_Pearson,m_PearsonMedian,m_PearsonPValue,m_Low95,m_Up95,TotBins,TotCtrlExprBins,TotCtrlBins,TotExprBins);
pAlignCnts = m_pAlignBins;
CurBin = 1;
for(Idx = 0; Idx < (int)m_NumAlignBins; Idx++, pAlignCnts++)
	{
	while(CurBin != pAlignCnts->Bin)
		{
		BuffIdx += sprintf(&szBuff[BuffIdx],",0");
		if((BuffIdx + 1000) > sizeof(szBuff))
			{
			CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
			BuffIdx = 0;
			}
		CurBin += 1;
		}
	BuffIdx += sprintf(&szBuff[BuffIdx],",%d",pAlignCnts->ControlSumCnts);
	CurBin += 1;
	if((BuffIdx + 1000) > sizeof(szBuff))
		{
		CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
		BuffIdx = 0;
		}
	}
while(CurBin <= TotBins)
	{
	BuffIdx += sprintf(&szBuff[BuffIdx],",0");
	if((BuffIdx + 1000) > sizeof(szBuff))
		{
		CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
		BuffIdx = 0;
		}
	CurBin += 1;
	}

BuffIdx += sprintf(&szBuff[BuffIdx],"\n\"%s\",%d,%d,%d,%d,%f,\"Experiment\",%f,%f,%f,%f,%f,%d,%d,%d,%d",
	pszFeatName,m_CurFeatLen,m_CurFeatCtrlCntsTotal,m_CurFeatExprCntsTotal,m_CurFeatCtrlCntsTotal+m_CurFeatExprCntsTotal,m_CurFoldChange,m_Pearson,m_PearsonMedian,m_PearsonPValue,m_Low95,m_Up95,TotBins,TotCtrlExprBins,TotCtrlBins,TotExprBins);

pAlignCnts = m_pAlignBins;
CurBin = 1;
for(Idx = 0; Idx < (int)m_NumAlignBins; Idx++, pAlignCnts++)
	{
	while(CurBin != pAlignCnts->Bin)
		{
		BuffIdx += sprintf(&szBuff[BuffIdx],",0");
		if((BuffIdx + 1000) > sizeof(szBuff))
			{
			CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
			BuffIdx = 0;
			}
		CurBin += 1;
		}
	BuffIdx += sprintf(&szBuff[BuffIdx],",%d",pAlignCnts->ExperimentSumCnts);
	CurBin += 1;
	if((BuffIdx + 1000) > sizeof(szBuff))
		{
		CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
		BuffIdx = 0;
		}
	}
while(CurBin <= TotBins)
	{
	BuffIdx += sprintf(&szBuff[BuffIdx],",0");
	if((BuffIdx + 100) > sizeof(szBuff))
		{
		CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
		BuffIdx = 0;
		}
	CurBin += 1;
	}
BuffIdx += sprintf(&szBuff[BuffIdx],"\n");
CUtility::SafeWrite(m_hBinCountsFile,szBuff,BuffIdx);
return(eBSFSuccess);
}

int
MannWhitney(char *pszFeatName)
{
char szBuff[16000];
int BuffIdx;
tsAlignBinCnts *pAlignCnts;
tsRankedCnts *pRankedCnts;
tsRankedCnts *pCnts; 
int Idy;
int Idx;
int Rank;
int TiedRank;
double RankSum;
double RankMean;
int TiedRanks;

int NumCtrls;
double SumCtrls;
int NumExprs;
double SumExprs;
double ScaledExperimentCnts;
	
size_t memreq;
UINT8 *pTmpAlloc;

static bool bHeaderRow = true;

if(bHeaderRow)
	{
	bHeaderRow = false;
	BuffIdx = sprintf(szBuff,"\"Feat\",\"FeatLen\",\"TotCtrlCnts\",\"TotExprCnts\",\"TotCtrlExprCnts\",\"FoldChange\",\"TotRanks\",\"CtrlRanks\",\"ExprRanks\",\"SumCtrlsRanks\",\"SumExprsRanks\",\"z\",\"Prob\",\"Pearson\",\"PearsonMedian\",\"PearsonPValue\",\"PearsonLow95\",\"PearsonUp95\"\n");
	}
else
	BuffIdx = 0;

if(m_NumAlignBins < 1)
	{
	BuffIdx += sprintf(&szBuff[BuffIdx],"\"%s\",%d,0,0,0,0.0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0\n",pszFeatName,m_CurFeatLen);
	CUtility::SafeWrite(m_hOutFile,szBuff,BuffIdx);
	return(eBSFSuccess);
	}

// iterate over alignment counts and copy (scale the experiment counts) into m_pRankedCnts
m_CurFeatCtrlCntsTotal = 0;
m_CurFeatExprCntsTotal = 0;
pAlignCnts = m_pAlignBins;
pRankedCnts = m_pRankedCnts;
m_NumRankedCnts = 0;
for(Idx = 0; Idx < (int)m_NumAlignBins; Idx++, pAlignCnts++)
	{
	if(m_NumRankedCnts + 10 > m_AllocdRankedCnts)
		{
		memreq = (m_NumRankedCnts + cAlignBinsReAlloc) * sizeof(tsRankedCnts);
#ifdef _WIN32
		pTmpAlloc = (UINT8 *) realloc(m_pRankedCnts,memreq);
#else
		pTmpAlloc = (UINT8 *)mremap(m_pRankedCnts,m_AllocdRankedCnts *  sizeof(tsRankedCnts),memreq,MREMAP_MAYMOVE);
		if(pTmpAlloc == MAP_FAILED)
			pTmpAlloc = NULL;
#endif
		if(pTmpAlloc == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"MannWhitney: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
			Reset();
			return(eBSFerrMem);
			}
		m_pRankedCnts = (tsRankedCnts *)pTmpAlloc;
		m_AllocdRankedCnts += cAlignBinsReAlloc;
		}

	m_CurFeatCtrlCntsTotal += pAlignCnts->ControlSumCnts;
	m_CurFeatExprCntsTotal += pAlignCnts->ExperimentSumCnts;

	if(pAlignCnts->ControlSumCnts > 0)
		{
		pRankedCnts->Value = pAlignCnts->ControlSumCnts;
		pRankedCnts->ExprFlag = 0;
		pRankedCnts->Rank = 0;
		pRankedCnts += 1;
		m_NumRankedCnts += 1;
		}

	ScaledExperimentCnts = (double)pAlignCnts->ExperimentSumCnts * m_LibSizeNormExpToCtrl;
	if(ScaledExperimentCnts > 0)
		{
		pRankedCnts->Value = ScaledExperimentCnts;
		pRankedCnts->ExprFlag = 1;
		pRankedCnts->Rank = 0;
		pRankedCnts += 1;
		m_NumRankedCnts += 1;
		}
	}

ScaledExperimentCnts = ((double)m_CurFeatExprCntsTotal * m_LibSizeNormExpToCtrl);
if(m_CurFeatExprCntsTotal > 0 && ScaledExperimentCnts <= 1.0)
	m_CurFeatExprCntsTotal = 1;
else
	m_CurFeatExprCntsTotal = (int)ScaledExperimentCnts;

// sort ranked counts descending - higher differences (more significant) at start of sorted array
if(m_NumRankedCnts > 1)
	qsort(m_pRankedCnts,m_NumRankedCnts,sizeof(tsRankedCnts),RankSortCnts);

// assign ranks : if adjacent diffs have equal values then assign these a mean rank
pRankedCnts = m_pRankedCnts;
TiedRanks = 0;
Rank = m_NumRankedCnts;
for(Idx = 0; Idx < (int)m_NumRankedCnts; Idx++, pRankedCnts++,Rank--)
	{
	if(TiedRanks)
		{
		pRankedCnts->Rank = RankMean;
		TiedRanks -= 1;
		continue;
		}
	
	// look ahead and check for tied ranks
	if((Idx+1)  < (int)m_NumRankedCnts && pRankedCnts->Value == pRankedCnts[1].Value)
		{
		// at least two tied ranks, could be more tied ranks..
		pCnts = pRankedCnts;
		TiedRanks = 1;
		TiedRank = Rank - 1;
		RankSum = (double)Rank;
		for(Idy = Idx+1; Idy < (int)m_NumRankedCnts; Idy++, pCnts++,TiedRank--)
			{
			if(pCnts->Value != pCnts[1].Value)
				break;
			TiedRanks += 1;
			RankSum += TiedRank;
			}
		RankMean = RankSum / TiedRanks;
		pRankedCnts->Rank = RankMean;
		TiedRanks -= 1;
		}
	else
		pRankedCnts->Rank = Rank;
	}
				

// sum the ranks for control and experiment
NumCtrls = 0;
NumExprs = 0;
SumCtrls = 0.0;
SumExprs = 0.0;
pRankedCnts = m_pRankedCnts;
for(Idx = 0; Idx < (int)m_NumRankedCnts; Idx++, pRankedCnts++)
	{
	if(pRankedCnts->ExprFlag == 0)
		{
		NumCtrls += 1;
		SumCtrls += pRankedCnts->Rank;
		}
	else
		{
		NumExprs += 1;
		SumExprs += pRankedCnts->Rank;
		}
	}

// check if either control or experiment have no entries
// if either with no entries then create psuedo entry with lowest rank of 1
// this simple heuristic will prevent problems later with division by 0 when calc'ing the Mann Whitney U-Test
if(NumCtrls == 0)
	{
	NumCtrls = 1;
	SumCtrls = 1;
	SumExprs += NumExprs;
	m_NumRankedCnts += 1;
	}
if(NumExprs == 0)
	{
	NumExprs = 1;
	SumExprs = 1;
	SumCtrls += NumCtrls;
	m_NumRankedCnts += 1;
	}

double Uc;
double Ue;
double U;
double ExpU;
double Sigma;
double z;
double Pz;
Uc =  SumCtrls - (((double)NumCtrls*(NumCtrls+1))/2.0);
Ue =  SumExprs - (((double)NumExprs*(NumExprs+1))/2.0);
U = min(Uc,Ue);

ExpU = ((double)NumCtrls * NumExprs)/2.0;
Sigma = sqrt((double)((double)NumCtrls * NumExprs * (NumCtrls + NumExprs + 1.0))/12.0);
z = (U - ExpU) / Sigma;
Pz = 1 - poz(abs(z));

m_Pearson = Pearsons(m_NumAlignBins,m_pAlignBins);
m_PearsonPValue = PearsonsPValue(m_Pearson,10000,m_NumAlignBins,m_pAlignBins,&m_Low95,&m_Up95,&m_PearsonMedian);

if(m_CurFeatCtrlCntsTotal == 0)
	m_CurFoldChange = 1.1 * m_CurFeatExprCntsTotal;
else
	{
	if(m_CurFeatExprCntsTotal == 0)
		m_CurFoldChange = -1.1 * m_CurFeatCtrlCntsTotal;
	else
		{
		m_CurFoldChange = (double)m_CurFeatExprCntsTotal/(double)m_CurFeatCtrlCntsTotal;
		if(m_CurFoldChange < 1.0)
			m_CurFoldChange = -1.0/m_CurFoldChange;
		}
	}

BuffIdx += sprintf(&szBuff[BuffIdx],"\"%s\",%d,%d,%d,%d,%f,%d,%d,%d,%f,%f,%f,%f,%f,%f,%f,%f,%f\n",
	pszFeatName,m_CurFeatLen,m_CurFeatCtrlCntsTotal,m_CurFeatExprCntsTotal,m_CurFeatCtrlCntsTotal+m_CurFeatExprCntsTotal,m_CurFoldChange,m_NumRankedCnts,NumCtrls,NumExprs,SumCtrls,SumExprs,z,Pz,m_Pearson,m_PearsonMedian,m_PearsonPValue,m_Low95,m_Up95);

CUtility::SafeWrite(m_hOutFile,szBuff,BuffIdx);

return(eBSFSuccess);
}

int
Wilcoxon(char *pszFeatName)
{
char szBuff[16000];
int BuffIdx;
tsAlignBinCnts *pAlignCnts;
tsRankedCnts *pRankedCnts;
tsRankedCnts *pCnts; 
int Idy;
int Idx;
int Rank;
int TiedRank;
double RankSum;
double RankMean;
int TiedRanks;

int NumCtrls;
double SumCtrls;
int NumExprs;
double SumExprs;
double ScaledExperimentCnts;
	
size_t memreq;
UINT8 *pTmpAlloc;

static bool bHeaderRow = true;

if(bHeaderRow)
	{
	bHeaderRow = false;
	BuffIdx = sprintf(szBuff,"\"Feat\",\"FeatLen\",\"TotCtrlCnts\",\"TotExprCnts\",\"TotCtrlExprCnts\",\"FoldChange\",\"TotRanks\",\"CtrlRanks\",\"ExprRanks\",\"SumCtrlsRanks\",\"SumExprsRanks\",\"z\",\"Prob\",\"Pearson\",\"PearsonMedian\",\"PearsonPValue\",\"PearsonLow95\",\"PearsonUp95\"\n");
	}
else
	BuffIdx = 0;

if(m_NumAlignBins < 1)
	{
	BuffIdx += sprintf(&szBuff[BuffIdx],"\"%s\",%d,0,0,0,0.0,0,0,0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0\n",pszFeatName,m_CurFeatLen);
	CUtility::SafeWrite(m_hOutFile,szBuff,BuffIdx);
	return(eBSFSuccess);
	}


// iterate over alignment counts and copy (scale the experiment counts) into m_pRankedCnts
m_CurFeatCtrlCntsTotal = 0;
m_CurFeatExprCntsTotal = 0;
pAlignCnts = m_pAlignBins;
pRankedCnts = m_pRankedCnts;
m_NumRankedCnts = 0;
for(Idx = 0; Idx < (int)m_NumAlignBins; Idx++, pAlignCnts++)
	{
	if(m_NumRankedCnts + 100 > m_AllocdRankedCnts)
		{
		memreq = (m_NumRankedCnts + cAlignBinsReAlloc) * sizeof(tsRankedCnts);
#ifdef _WIN32
		pTmpAlloc = (UINT8 *) realloc(m_pRankedCnts,memreq);
#else
		pTmpAlloc = (UINT8 *)mremap(m_pRankedCnts,m_AllocdRankedCnts *  sizeof(tsRankedCnts),memreq,MREMAP_MAYMOVE);
		if(pTmpAlloc == MAP_FAILED)
			pTmpAlloc = NULL;
#endif
		if(pTmpAlloc == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"MannWhitney: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
			Reset();
			return(eBSFerrMem);
			}
		m_pRankedCnts = (tsRankedCnts *)pTmpAlloc;
		m_AllocdRankedCnts += cAlignBinsReAlloc;
		}

	m_CurFeatCtrlCntsTotal += pAlignCnts->ControlSumCnts;
	m_CurFeatExprCntsTotal += pAlignCnts->ExperimentSumCnts;

	ScaledExperimentCnts = (double)pAlignCnts->ExperimentSumCnts * m_LibSizeNormExpToCtrl;
	if(pAlignCnts->ControlSumCnts == (UINT32)(ScaledExperimentCnts + 0.5))
		continue;
	
	if((double)pAlignCnts->ControlSumCnts > ScaledExperimentCnts)
		{
		pRankedCnts->Value = (double)pAlignCnts->ControlSumCnts - ScaledExperimentCnts;
		pRankedCnts->ExprFlag = 0;
		}
	else
		{
		pRankedCnts->Value = ScaledExperimentCnts - (double)pAlignCnts->ControlSumCnts;
		pRankedCnts->ExprFlag = 1;
		}
	pRankedCnts->Rank = 0;
	pRankedCnts += 1;
	m_NumRankedCnts += 1;
	}

ScaledExperimentCnts = ((double)m_CurFeatExprCntsTotal * m_LibSizeNormExpToCtrl);
if(m_CurFeatExprCntsTotal > 0 && ScaledExperimentCnts <= 1.0)
	m_CurFeatExprCntsTotal = 1;
else
	m_CurFeatExprCntsTotal = (int)ScaledExperimentCnts;

// sort ranked counts descending - higher differences (more significant) at start of sorted array
if(m_NumRankedCnts > 1)
	qsort(m_pRankedCnts,m_NumRankedCnts,sizeof(tsRankedCnts),RankSortCnts);

// assign ranks : if adjacent diffs have equal values then assign these a mean rank
pRankedCnts = m_pRankedCnts;
TiedRanks = 0;
Rank = m_NumRankedCnts;
for(Idx = 0; Idx < (int)m_NumRankedCnts; Idx++, pRankedCnts++,Rank--)
	{
	if(TiedRanks)
		{
		pRankedCnts->Rank = RankMean;
		TiedRanks -= 1;
		continue;
		}
	
	// look ahead and check for tied ranks
	if((Idx+1)  < (int)m_NumRankedCnts && pRankedCnts->Value == pRankedCnts[1].Value)
		{
		// at least two tied ranks, could be more tied ranks..
		pCnts = pRankedCnts;
		TiedRanks = 1;
		TiedRank = Rank - 1;
		RankSum = Rank;
		for(Idy = Idx+1; Idy < (int)m_NumRankedCnts; Idy++, pCnts++,TiedRank--)
			{
			if(pCnts->Value != pCnts[1].Value)
				break;
			TiedRanks += 1;
			RankSum += TiedRank;
			}
		RankMean = RankSum / TiedRanks;
		pRankedCnts->Rank = RankMean;
		TiedRanks -= 1;
		}
	else
		pRankedCnts->Rank = Rank;
	}
				

// sum the ranks for control and experiment
NumCtrls = 0;
NumExprs = 0;
SumCtrls = 0.0;
SumExprs = 0.0;
pRankedCnts = m_pRankedCnts;

for(Idx = 0; Idx < (int)m_NumRankedCnts; Idx++, pRankedCnts++)
	{
	if(pRankedCnts->ExprFlag == 0)
		{
		NumCtrls += 1;
		SumCtrls += pRankedCnts->Rank;
		}
	else
		{
		NumExprs += 1;
		SumExprs += pRankedCnts->Rank;
		}
	}

// check if either control or experiment have no entries
// if either with no entries then create psuedo entry with lowest rank of 1
// this simple heuristic will prevent problems later with division by 0 when calc'ing the Wilcoxon scaled rank
if(NumCtrls == 0)
	{
	NumCtrls = 1;
	SumCtrls = 1;
	SumExprs += NumExprs;
	m_NumRankedCnts += 1;
	}
if(NumExprs == 0)
	{
	NumExprs = 1;
	SumExprs = 1;
	SumCtrls += NumCtrls;
	m_NumRankedCnts += 1;
	}

double mean;
double stddev;
double z;
double Pz;

mean = (m_NumRankedCnts * (m_NumRankedCnts + 1))/4;
stddev = sqrt((((double)m_NumRankedCnts * (m_NumRankedCnts + 1)) * ((2 * m_NumRankedCnts)+1))/24.0);

z = (SumCtrls - mean) / stddev;
Pz = 1 - poz(abs(z));

m_Pearson = Pearsons(m_NumAlignBins,m_pAlignBins);
m_PearsonPValue = PearsonsPValue(m_Pearson,10000,m_NumAlignBins,m_pAlignBins,&m_Low95,&m_Up95,&m_PearsonMedian);
if(m_CurFeatCtrlCntsTotal == 0)
	m_CurFoldChange = 1.1 * m_CurFeatExprCntsTotal;
else
	{
	if(m_CurFeatExprCntsTotal == 0)
		m_CurFoldChange = -1.1 * m_CurFeatCtrlCntsTotal;
	else
		{
		m_CurFoldChange = (double)m_CurFeatExprCntsTotal/(double)m_CurFeatCtrlCntsTotal;
		if(m_CurFoldChange < 1.0)
			m_CurFoldChange = -1.0/m_CurFoldChange;
		}
	}

BuffIdx += sprintf(&szBuff[BuffIdx],"\"%s\",%d,%d,%d,%d,%f,%d,%d,%d,%f,%f,%f,%f,%f,%f,%f,%f,%f\n",
	pszFeatName,m_CurFeatLen,m_CurFeatCtrlCntsTotal,m_CurFeatExprCntsTotal,m_CurFeatCtrlCntsTotal+m_CurFeatExprCntsTotal,m_CurFoldChange,m_NumRankedCnts,NumCtrls,NumExprs,SumCtrls,SumExprs,z,Pz,m_Pearson,m_PearsonMedian,m_PearsonPValue,m_Low95,m_Up95);

CUtility::SafeWrite(m_hOutFile,szBuff,BuffIdx);

return(eBSFSuccess);
}

// SortAlignments
// Sort by ascending chrom identifier, loci, strand, control, experiment
static int
SortAlignments(const void *arg1, const void *arg2)
{
tsAlignHit *pEl1 = (tsAlignHit *)arg1;
tsAlignHit *pEl2 = (tsAlignHit *)arg2;

if(pEl1->ChromID < pEl2->ChromID)
		return(-1);
if(pEl1->ChromID > pEl2->ChromID)
	return(1);

if(pEl1->Loci < pEl2->Loci )
		return(-1);
if(pEl1->Loci > pEl2->Loci )
	return(1);
if(pEl1->Strand < pEl2->Strand )
		return(-1);
if(pEl1->Strand > pEl2->Strand )
	return(1);

if(pEl1->ExprFlag < pEl2->ExprFlag )
		return(-1);
if(pEl1->ExprFlag > pEl2->ExprFlag )
	return(1);

return(0);
}

// RankSortCnts
// Sort by descending values (higher values at start of sorted array)
static int
RankSortCnts(const void *arg1, const void *arg2)
{
tsRankedCnts *pEl1 = (tsRankedCnts *)arg1;
tsRankedCnts *pEl2 = (tsRankedCnts *)arg2;

if(pEl1->Value > pEl2->Value)
	return(-1);
if(pEl1->Value < pEl2->Value)
	return(1);
return(0);
}

// SortPearsons
// Sort by ascending values (lower values at start of sorted array)
static int
SortPearsons(const void *arg1, const void *arg2)
{
double *pEl1 = (double *)arg1;
double *pEl2 = (double *)arg2;

if(*pEl1 < *pEl2)
	return(-1);
if(*pEl1 > *pEl2)
	return(1);
return(0);
}


/*HEADER
	Module:       z.c
	Purpose:      compute approximations to normal z distribution probabilities
	Programmer:   Gary Perlman
	Organization: Wang Institute, Tyngsboro, MA 01879
	Tester:       compile with -DZTEST to include main program
	Copyright:    none
	Tabstops:     4
*/

/*LINTLIBRARY*/
static char sccsfid[] = "@(#) z.c 5.1 (|stat) 12/26/85";
#include	<math.h>

#define	Z_EPSILON      0.000001       /* accuracy of critz approximation */
#define	Z_MAX          6.0            /* maximum meaningful z value */


double	critz (double	p);


/*FUNCTION poz: probability of normal z value */
/*ALGORITHM
	Adapted from a polynomial approximation in:
		Ibbetson D, Algorithm 209
		Collected Algorithms of the CACM 1963 p. 616
	Note:
		This routine has six digit accuracy, so it is only useful for absolute
		z values < 6.  For z values >= to 6.0, poz() returns 0.0.
*/
double            /*VAR returns cumulative probability from -oo to z */
poz (double	z)        /*VAR normal z value */
	{
	double	y, x, w;
	
	if (z == 0.0)
		x = 0.0;
	else
		{
		y = 0.5 * fabs (z);
		if (y >= (Z_MAX * 0.5))
			x = 1.0;
		else if (y < 1.0)
			{
			w = y*y;
			x = ((((((((0.000124818987 * w
				-0.001075204047) * w +0.005198775019) * w
				-0.019198292004) * w +0.059054035642) * w
				-0.151968751364) * w +0.319152932694) * w
				-0.531923007300) * w +0.797884560593) * y * 2.0;
			}
		else
			{
			y -= 2.0;
			x = (((((((((((((-0.000045255659 * y
				+0.000152529290) * y -0.000019538132) * y
				-0.000676904986) * y +0.001390604284) * y
				-0.000794620820) * y -0.002034254874) * y
				+0.006549791214) * y -0.010557625006) * y
				+0.011630447319) * y -0.009279453341) * y
				+0.005353579108) * y -0.002141268741) * y
				+0.000535310849) * y +0.999936657524;
			}
		}
	return (z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5));
	}

/*FUNCTION critz: compute critical z value to produce given probability */
/*ALGORITHM
	Begin with upper and lower limits for z values (maxz and minz)
	set to extremes.  Choose a z value (zval) between the extremes.
	Compute the probability of the z value.  Set minz or maxz, based
	on whether the probability is less than or greater than the
	desired p.  Continue adjusting the extremes until they are
	within Z_EPSILON of each other.
*/
double        /*VAR returns z such that fabs (poz(p) - z) <= .000001 */
critz (double	p)    /*VAR critical probability level */
	{
	double	minz = -Z_MAX;    /* minimum of range of z */
	double	maxz = Z_MAX;     /* maximum of range of z */
	double	zval = 0.0;       /* computed/returned z value */
	double	pval;			  /* prob (z) function, pval := poz (zval) */
	
	if (p <= 0.0 || p >= 1.0)
		return (0.0);
	
	while (maxz - minz > Z_EPSILON)
		{
		pval = poz (zval);
		if (pval > p)
			maxz = zval;
		else
			minz = zval;
		zval = (maxz + minz) * 0.5;
		}
	return (zval);
	}
